<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django日常总结]]></title>
    <url>%2F2019%2F03%2F27%2FDjango%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[\1. 对Django的认识？ ;) #1.Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。#2.Django内置的ORM跟框架内的其他模块耦合程度高。#应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于其ORM的便利；#理论上可以切换掉其ORM模块，但这就相当于要把装修完毕的房子拆除重新装修，倒不如一开始就去毛胚房做全新的装修。#3.Django的卖点是超高的开发效率，其性能扩展有限；采用Django的项目，在流量达到一定规模后，都需要对其进行重构，才能满足性能的要求。#4.Django适用的是中小型的网站，或者是作为大型网站快速实现产品雏形的工具。#5.Django模板的设计哲学是彻底的将代码、样式分离； Django从根本上杜绝在模板中进行编码、处理数据的可能。 ;) \2. Django 、Flask、Tornado的对比 ;) #1.Django走的是大而全的方向,开发效率高。它的MTV框架,自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器#给开发者提高了超高的开发效率#2.Flask是轻量级的框架,自由,灵活,可扩展性很强,核心基于Werkzeug WSGI工具和jinja2模板引擎#3.Tornado走的是少而精的方向,性能优越。它最出名的是异步非阻塞的设计方式#Tornado的两大核心模块：# 1.iostraem：对非阻塞式的socket进行简单的封装# 2.ioloop：对I/O多路复用的封装，它实现了一个单例 ;) \3. 什么是wsgi,uwsgi,uWSGI？ ;) #WSGI:# web服务器网关接口,是一套协议。用于接收用户请求并将请求进行初次封装，然后将请求交给web框架# 实现wsgi协议的模块：# 1.wsgiref,本质上就是编写一个socket服务端，用于接收用户请求(django)# 2.werkzeug,本质上就是编写一个socket服务端，用于接收用户请求(flask)#uwsgi:# 与WSGI一样是一种通信协议，它是uWSGI服务器的独占协议,用于定义传输信息的类型#uWSGI:# 是一个web服务器,实现了WSGI协议,uWSGI协议,http协议, ;) \4. django请求的生命周期？ ;) #1.wsgi,请求封装后交给web框架 （Flask、Django） #2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session - #3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数 #4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates =&gt; 渲染 - #5.中间件，对响应的数据进行处理。 #6.wsgi,将响应的内容发送给浏览器。 ;) \5. 简述什么是FBV和CBV？ #FBV和CBV本质是一样的#基于函数的视图叫做FBV，基于类的视图叫做CBV#在python中使用CBV的优点：#1.提高了代码的复用性，可以使用面向对象的技术，比如Mixin（多继承）#2.可以用不同的函数针对不同的HTTP方法处理，而不是通过很多if判断，提高代码可读性 \6. 如何给CBV的程序添加装饰器？ ;) #引入method_decorator模块#1.直接在类上加装饰器#@method_decorator(test,name=&apos;dispatch&apos;)#class Loginview(View):# pass#2.直接在处理的函数前加装饰器#@method_decorator(test)# def post(self,request,*args,**kwargs):pass ;) \7. 简述MVC和MTV ;) #MVC软件系统分为三个基本部分：模型(Model)、视图(View)和控制器(Controller)#Model：负责业务对象与数据库的映射(ORM)#View：负责与用户的交互#Control：接受用户的输入调用模型和视图完成用户的请求#Django框架的MTV设计模式借鉴了MVC框架的思想,三部分为：Model、Template和View#Model(模型)：负责业务对象与数据库的对象(ORM)#Template(模版)：负责如何把页面展示给用户#View(视图)：负责业务逻辑，并在适当的时候调用Model和Template#此外,Django还有一个urls分发器,#它将一个个URL的页面请求分发给不同的view处理,view再调用相应的Model和Template ;) \8. django路由系统中name的作用？ #用于反向解析路由,相当于给url取个别名，只要这个名字不变,即使对应的url改变#通过该名字也能找到该条url \9. 列举django的内置组件？ #1.Admin是对model中对应的数据表进行增删改查提供的组件#2.model组件：负责操作数据库#3.form组件：1.生成HTML代码2.数据有效性校验3校验信息返回并展示#4.ModelForm组件即用于数据库操作,也可用于用户请求的验证 \10. 说一下Django，MIDDLEWARES中间件的作用和应用场景？ ;) #中间件是介于request与response处理之间的一道处理过程,用于在全局范围内改变Django的输入和输出。#简单的来说中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作#例如：#1.Django项目中默认启用了csrf保护,每次请求时通过CSRF中间件检查请求中是否有正确#token值#2.当用户在页面上发送请求时，通过自定义的认证中间件，判断用户是否已经登陆，未登陆就去登陆。#3.当有用户请求过来时，判断用户是否在白名单或者在黑名单里 ;) \11. 列举django中间件的5个方法？ #1.process_request : 请求进来时,权限认证#2.process_view : 路由匹配之后,能够得到视图函数#3.process_exception : 异常时执行#4.process_template_responseprocess : 模板渲染时执行#5.process_response : 请求有响应时执行 \12. django的request对象是在什么时候创建的？ #class WSGIHandler(base.BaseHandler):# request = self.request_class(environ)#请求走到WSGIHandler类的时候，执行__cell__方法，将environ封装成了request \13. Django重定向是如何实现的？用的什么状态码？ ;) #1.使用HttpResponseRedirect#from django.http import HttpResponseRedirect #2.使用redirect和reverse#状态码：301和302#301和302的区别：#相同点：都表示重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址#不同点：#301比较常用的场景是使用域名跳转。比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com#表示旧地址A的资源已经被永久地移除了#302用来做临时跳转，比如未登陆的用户访问用户中心重定向到登录页面。表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B ;) \14. xxss攻击 ;) #-- XSS攻击是向网页中注入恶意脚本，用在用户浏览网页时，在用户浏览器中执行恶意脚本的攻击。# -- XSS分类，反射型xss ，存储型xss# -- 反射型xss又称为非持久型xss，攻击者通过电子邮件等方式将包含注入脚本的链接发送给受害者，# 受害者通过点击链接，执行注入脚本，达到攻击目的。# -- 持久型xss跟反射型的最大不同是攻击脚本将被永久的存放在目标服务器的数据库和文件中，多见于论坛# 攻击脚本连同正常信息一同注入到帖子内容当中，当浏览这个被注入恶意脚本的帖子的时候，恶意脚本会被执行# -- 防范措施 1 输入过滤 2 输出编码 3 cookie防盗# 1，输入过滤 用户输入进行检测 不允许带有js代码# 2，输出编码 就是把我们的脚本代码变成字符串形式输出出来# 3，cookie加密 #向页面注入恶意的代码,这些代码被浏览器执行#XSS攻击能做些什么：# 1.窃取cookies# 2.读取用户未公开的资料，如果：邮件列表或者内容、系统的客户资料，联系人列表#解决方法:# 1.客户度端：表单提交之前或者url传递之前,对需要的参数进行过滤# 2.服务器端：检查用户输入的内容是否有非法内容 ;) \15. django中csrf的实现机制 #第一步：django第一次响应来自某个客户端的请求时,后端随机产生一个token值，把这个token保存在SESSION状态中;同时,后端把这个token放到cookie中交给前端页面；#第二步：下次前端需要发起请求（比如发帖）的时候把这个token值加入到请求数据或者头信息中,一起传给后端；Cookies:&#123;csrftoken:xxxxx&#125;#第三步：后端校验前端请求带过来的token和SESSION里的token是否一致； \16. 基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf token？ ;) #1.后端将csrftoken传到前端，发送post请求时携带这个值发送data: &#123; csrfmiddlewaretoken: &apos;&#123;&#123; csrf_token &#125;&#125;&apos; &#125;,#2.获取form中隐藏标签的csrftoken值，加入到请求数据中传给后端 data: &#123; csrfmiddlewaretoken:$(&apos;[name=&quot;csrfmiddlewaretoken&quot;]&apos;).val() &#125;,#3.cookie中存在csrftoken,将csrftoken值放到请求头中headers:&#123; &quot;X-CSRFtoken&quot;:$.cookie(&quot;csrftoken&quot;)&#125;， ;) \17. Django本身提供了runserver，为什么不能用来部署？(runserver与uWSGI的区别) #1.runserver方法是调试 Django 时经常用到的运行方式，它使用Django自带的#WSGI Server 运行，主要在测试和开发中使用，并且 runserver 开启的方式也是单进程 。#2.uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http 等协议。注意uwsgi是一种通信协议，而uWSGI是实现uwsgi协议和WSGI协议的 Web 服务器。#uWSGI具有超快的性能、低内存占用和多app管理等优点，并且搭配着Nginx就是一个生产环境了，能够将用户访问请求与应用 app 隔离开，实现真正的部署 。#相比来讲，支持的并发量更高，方便管理多进程，发挥多核的优势，提升性能。 \18. cookie和session的区别： ;) #1.cookie:# cookie是保存在浏览器端的键值对,可以用来做用户认证#2.session：# 将用户的会话信息保存在服务端,key值是随机产生的自符串,value值时session的内容# 依赖于cookie将每个用户的随机字符串保存到用户浏览器上#Django中session默认保存在数据库中：django_session表#flask,session默认将加密的数据写在用户的cookie中 ;) \19. 列举django orm 中所有的方法（QuerySet对象的所有方法） ;) #&lt;1&gt; all(): 查询所有结果 #&lt;2&gt; filter(**kwargs): 它包含了与所给筛选条件相匹配的对象。获取不到返回None#&lt;3&gt; get(**kwargs): 返回与所给筛选条件相匹配的对象，返回结果有且只有一个。获取不到会抱胸#如果符合筛选条件的对象超过一个或者没有都会抛出错误。#&lt;4&gt; exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象#&lt;5&gt; order_by(*field): 对查询结果排序#&lt;6&gt; reverse(): 对查询结果反向排序 #&lt;8&gt; count(): 返回数据库中匹配查询(QuerySet)的对象数量。 #&lt;9&gt; first(): 返回第一条记录 #&lt;10&gt; last(): 返回最后一条记录 #&lt;11&gt; exists(): 如果QuerySet包含数据，就返回True，否则返回False#&lt;12&gt; values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系 model的实例化对象，而是一个可迭代的字典序列#&lt;13&gt; values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列#&lt;14&gt; distinct(): 从返回结果中剔除重复纪录 ;) \20. only和defer的区别？ #only:从数据库中只取指定字段的内容#defer：指定字段的内容不被检索 \21. select_related和prefetch_related的区别？ #有外键存在时，可以很好的减少数据库请求的次数,提高性能#select_related通过多表join关联查询,一次性获得所有数据,只执行一次SQL查询#prefetch_related分别查询每个表,然后根据它们之间的关系进行处理,执行两次查询 \22. filter和exclude的区别？ #取到的值都是QuerySet对象,filter选择满足条件的,exclude:排除满足条件的. \23. F和Q的作用? #F:对数据本身的不同字段进行操作 如:比较和更新#Q：用于构造复杂的查询条件 如：&amp; |操作 \24. values和values_list的区别？ #values : 取字典的queryset#values_list : 取元组的queryset \25. 如何使用django orm批量创建数据？ #bulk_create()#objs=[models.Book(title=&quot;图书&#123;&#125;&quot;.format(i+15)) for i in range(100)]#models.Book.objects.bulk_create(objs) \26. django的Form和ModeForm的作用？ ;) #Form作用：# 1.在前端生成HTML代码# 2.对数据作有效性校验# 3.返回校验信息并展示#ModeForm：根据模型类生成From组件,并且可以操作数据库 ;) \27. django的Form组件中,如果字段中包含choices参数，请使用两种方式实现数据源实时更新。 #1.重写构造函数def def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.fields[&quot;city&quot;].widget.choices = models.City.objects.all().values_list(&quot;id&quot;, &quot;name&quot;)#2.利用ModelChoiceField字段,参数为queryset对象 \28. django的Model中的ForeignKey字段中的on_delete参数有什么作用？ #删除关联表中的数据时,当前表与其关联的field的操作#django2.0之后，表与表之间关联的时候,必须要写on_delete参数,否则会报异常 \29. django如何实现websocket？ # 列举django orm中三种能写sql语句的方法。 #1.使用execute执行自定义的SQL#2.使用extra方法 #3.使用raw方法# 1.执行原始sql并返回模型# 2.依赖model多用于查询 \30. django orm 中如何设置读写分离？ ;) #1.手动读写分离:通过.using(db_name)来指定要使用的数据库#2.自动读写分离:# 1.定义类：如Router# 2.配置Router# settings.py中指定DATABASE_ROUTERS# DATABASE_ROUTERS = [&apos;myrouter.Router&apos;,] #提高读的性能：多配置几个数据库,并在读取时,随机选取。写的时候写到主库#实现app之间的数据库分离：分库分表 ;) \31. django中如何实现orm表中添加数据时创建一条日志记录。 \32. django内置的缓存机制？ ;) # 全站缓存MIDDLEWARE_CLASSES = ( ‘django.middleware.cache.UpdateCacheMiddleware’, #第一 &apos;django.middleware.common.CommonMiddleware&apos;, ‘django.middleware.cache.FetchFromCacheMiddleware’, #最后) # 视图缓存from django.views.decorators.cache import cache_pageimport time @cache_page(15) #超时时间为15秒def index(request): t=time.time() #获取当前时间 return render(request,&quot;index.html&quot;,locals()) # 模板缓存&#123;% load cache %&#125; &lt;h3 style=&quot;color: green&quot;&gt;不缓存:-----&#123;&#123; t &#125;&#125;&lt;/h3&gt; &#123;% cache 2 &apos;name&apos; %&#125; # 存的key &lt;h3&gt;缓存:-----:&#123;&#123; t &#125;&#125;&lt;/h3&gt;&#123;% endcache %&#125; ;) \33. django的缓存能使用redis吗？如果可以的话，如何配置？ ;) #1.安装 pip install django-redis#2.在stting中配置CACHES,可以设置多个缓存,根据名字使用 CACHES = &#123; &quot;default&quot;: &#123; &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379&quot;, &quot;OPTIONS&quot;: &#123; &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, &quot;CONNECTION_POOL_KWARGS&quot;: &#123;&quot;max_connections&quot;: 100&#125; # &quot;PASSWORD&quot;: &quot;密码&quot;, &#125; &#125; &#125;, #另添加缓存 &quot;JERD&quot;: &#123; &#125;#3.根据名字去连接池中获取连接 from django_redis import get_redis_connection conn = get_redis_connection(&quot;default&quot;) ;) \34. django的模板中filter和simple_tag的区别？ ;) # 自定义filter：&#123;&#123; 参数1|filter函数名:参数2 &#125;&#125;# 1.可以与if标签来连用# 2.自定义时需要写两个形参# simple_tag:&#123;% simple_tag函数名 参数1 参数2 %&#125;# 1.可以传多个参数,没有限制# 2.不能与if标签来连用 ;) \35. django-debug-toolbar的作用？ #1.是django的第三方工具包,给django扩展了调试功能#包括查看sql语句,db查询次数,request,headers等 \36. django中如何实现单元测试？ \37. 解释orm中 db first 和 code first的含义？ #数据持久化的方式：#db first基于已存在的数据库,生成模型#code first基于已存在的模型,生成数据库库 \38. django中如何根据数据库表生成model中的类？ #1.在settings中设置要连接的数据库#2.生成model模型文件#python manage.py inspectdb#3.模型文件导入到models中# python manage.py inspectdb &gt; app/models.py \39. 使用orm和原生sql的优缺点？ #1.orm的开发速度快,操作简单。使开发更加对象化#执行速度慢。处理多表联查等复杂操作时,ORM的语法会变得复杂#2.sql开发速度慢,执行速度快。性能强 \40. django的contenttype组件的作用？ #这个组件保存了项目中所有app和model的对应关系,每当我们创建了新的model并执行数据库迁移后，ContentType表中就会自动新增一条记录#当一张表和多个表FK关联,并且多个FK中只能选择其中一个或其中n个时,可以利用contenttypes \41. 谈谈你对restful规范的认识？ ;) #首先restful是一种软件架构风格或者说是一种设计风格，并不是标准，它只是提供了一组设计#原则和约束条件，主要用于客户端和服务器交互类的软件。 #就像设计模式一样，并不是一定要遵循这些原则，而是基于这个风格设计的软件可以更简洁，更#有层次，我们可以根据开发的实际情况，做相应的改变。#它里面提到了一些规范，例如：#1.restful 提倡面向资源编程,在url接口中尽量要使用名词，不要使用动词 #2、在url接口中推荐使用Https协议，让网络接口更加安全#https://www.bootcss.com/v1/mycss？page=3#（Https是Http的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，#因此加密的详细内容就需要SSL（安全套接层协议）） #3、在url中可以体现版本号#https://v1.bootcss.com/mycss#不同的版本可以有不同的接口，使其更加简洁，清晰 #4、url中可以体现是否是API接口 #https://www.bootcss.com/api/mycss #5、url中可以添加条件去筛选匹配#https://www.bootcss.com/v1/mycss？page=3 #6、可以根据Http不同的method，进行不同的资源操作#（5种方法：GET / POST / PUT / DELETE / PATCH） #7、响应式应该设置状态码#8、有返回值，而且格式为统一的json格式 #9、返回错误信息#返回值携带错误信息 #10、返回结果中要提供帮助链接，即API最好做到Hypermedia#如果遇到需要跳转的情况 携带调转接口的URL ret = &#123; code: 1000, data:&#123; id:1, name:&apos;小强&apos;, depart_id:http://www.luffycity.com/api/v1/depart/8/ &#125; &#125; ;) \42. 接口的幂等性是什么意思？ #1.是系统的接口对外一种承诺(而不是实现)#2.承诺只要调用接口成功,外部多次调用对系统的影响都是一致的,不会对资源重复操作 \43. 什么是RPC？ #远程过程调用 (RPC) 是一种协议，程序可使用这种协议向网络中的另一台计算机上的程序请求服务#1.RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。#2.首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。#2.在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，#3.最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。 \44. 为什么要使用API #系统之间为了调用数据。#数据传输格式:# 1.json# 2.xml \45. 为什么要使用django rest framework框架？ #能自动生成符合 RESTful 规范的 API#1.在开发REST API的视图中，虽然每个视图具体操作的数据不同，#但增、删、改、查的实现流程基本一样,这部分的代码可以简写#2.在序列化与反序列化时，虽然操作的数据不同，但是执行的过程却相似,这部分的代码也可以简写#REST framework可以帮助简化上述两部分的代码编写，大大提高REST API的开发速度 \46. django rest framework框架中都有那些组件？ ;) #1.序列化组件:serializers 对queryset序列化以及对请求数据格式校验#2.路由组件routers 进行路由分发#3.视图组件ModelViewSet 帮助开发者提供了一些类，并在类中提供了多个方法#4.认证组件 写一个类并注册到认证类(authentication_classes)，在类的的authticate方法中编写认证逻#5.权限组件 写一个类并注册到权限类(permission_classes)，在类的的has_permission方法中编写认证逻辑。 #6.频率限制 写一个类并注册到频率类(throttle_classes)，在类的的allow_request/wait 方法中编写认证逻辑#7.解析器 选择对数据解析的类，在解析器类中注册(parser_classes)#8.渲染器 定义数据如何渲染到到页面上,在渲染器类中注册(renderer_classes)#9.分页 对获取到的数据进行分页处理, pagination_class#10.版本 版本控制用来在不同的客户端使用不同的行为#在url中设置version参数，用户请求时候传入参数。在request.version中获取版本，根据版本不同 做不同处理 ;) \47. django rest framework框架中的视图都可以继承哪些类？ ;) #class View(object):#class APIView(View): 封装了view,并且重新封装了request,初始化了各种组件#class GenericAPIView(views.APIView):#1.增加了一些属性和方法,如get_queryset,get_serializer#class GenericViewSet(ViewSetMixin, generics.GenericAPIView)#父类ViewSetMixin 重写了as_view,返回return csrf_exempt(view)#并重新设置请求方式与执行函数的关系#class ModelViewSet(mixins.CreateModelMixin,# mixins.RetrieveModelMixin,# mixins.UpdateModelMixin,# mixins.DestroyModelMixin,# mixins.ListModelMixin,# GenericViewSet):pass#继承了mixins下的一些类,封装了list,create,update等方法#和GenericViewSet ;) \48. 简述 django rest framework框架的认证流程 #1.用户请求走进来后,走APIView,初始化了默认的认证方法#2.走到APIView的dispatch方法,initial方法调用了request.user#3.如果我们配置了认证类,走我们自己认证类中的authentication方法 \49. django rest framework如何实现的用户访问频率控制 #使用IP/用户账号作为键，每次的访问时间戳作为值，构造一个字典形式的数据，存起来，每次访问时对时间戳列表的元素进行判断，#把超时的删掉，再计算列表剩余的元素数就能做到频率限制了 #匿名用户：使用IP控制，但是无法完全控制，因为用户可以换代理IP登录用户：使用账号控制，但是如果有很多账号，也无法限制 \50. rest_framework序列化组件的作用,以及一些外键关系的钩子方法 ;) #作用：帮助我们序列化数据#1.choices get_字段名_display#2.ForeignKey source=orm 操作#3.ManyToManyFiled SerializerMethodField()# def get_字段名():# return 自定义 ;) \51. 给用户提供一个接口之前需要提前做什么 #1.跟前端进行和交互,确定前端要什么#2.把需求写个文档保存 \52. PV和UV #1.pv:页面访问量,没打开一次页面PV计算+1,页面刷新也是#2.UV：独立访问数,一台电脑终端为一个访客 \53. 什么是跨域以及解决方法: ;) #跨域：# 浏览器从一个域名的网页去请求另一个域名的资源时,浏览器处于安全的考虑,不允许不同源的请求#同源策略：# 协议相同# 域名相同# 端口相同#处理方法：# 1.通过JSONP跨域# JSON是一种数据交换格式# JSONP是一种非官方的跨域数据交互协议# jsonp是包含在函数调用中的json# script标签不受同源策略的影响，手动创建一个script标签,传递URL,同时传入一个回调函数的名字# 服务器得到名字后,返回数据时会用这个函数名来包裹住数据,客户端获取到数据之后，立即把script标签删掉# 2.cors：跨域资源共享# 使用自定义的HTTP头部允许浏览器和服务器相互通信# 1.如果是简单请求,直接设置允许访问的域名：# 允许你的域名来获取我的数据 # response[&apos;Access-Control-Allow-Origin&apos;] = &quot;*&quot;# 2.如果是复杂请求,首先会发送options请求做预检,然后再发送真正的PUT/POST....请求# 因此如果复杂请求是PUT等请求,则服务端需要设置允许某请求# 如果复杂请求设置了请求头，则服务端需要设置允许某请求头#简单请求：# 一次请求 #非简单请求：# 两次请求，在发送数据之前会先发一次请求用于做“预检”，# 只有“预检”通过后才再发送一次请求用于数据传输。#只要同时满足以下两大条件，就属于简单请求。 # (1) 请求方法是以下三种方法之一：HEAD GET POST# (2)HTTP的头信息不超出以下几种字段： # Accept # Accept-Language # Content-Language# Last-Event-ID# Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、 text/plain #JSONP和CORS：# 1.JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求# 2.jsonp需要client和server端的相互配合# 3.cors在client端无需设置，server端需要针对不同的请求，来做head头的处理 ;) \54. 如何实现用户的登陆认证 #1.cookie session#2.token 登陆成功后生成加密字符串#3.JWT：json wed token缩写 它将用户信息加密到token中,服务器不保存任何用户信息#服务器通过使用保存的密钥来验证token的正确性 \55. 如何将dict转换成url的格式： #使用urlencode#from urllib.parse import urlencode#post_data=&#123;&quot;k1&quot;：&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;&#125;#ret=urlencode(post_data)#print(ret,type(ret)) #k1=v1&amp;k2=v2 &lt;class &apos;str&apos;&gt;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django高并发]]></title>
    <url>%2F2019%2F03%2F26%2Fdjango%E9%AB%98%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[nginx + uWSGI 为 django 提供高并发django 的并发能力真的是令人担忧，这里就使用 nginx + uwsgi 提供高并发 nginx 的并发能力超高，单台并发能力过万（这个也不是绝对），在纯静态的 web 服务中更是突出其优越的地方，由于其底层使用 epoll 异步IO模型进行处理，使其深受欢迎 做过运维的应该都知道，php 需要使用 nginx + fastcgi 提供高并发，java 需要使用 nginx + tomcat 提供 web 服务 下面介绍如何使用 nginx + uwsgi 为 django 提供高并发 web 服务 1、系统环境 [root@crazy-acong ~]# uname -aLinux crazy-acong 2.6.32-504.el6.x86_64 #1 SMP Wed Oct 15 04:27:16 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux[root@crazy-acong ~]# cat /etc/redhat-release CentOS release 6.6 (Final) 2、python 及 django 版本 [root@crazy-acong ~]# python3 --versionPython 3.4.4[root@crazy-acong ~]# django-admin --version1.10.6 3、安装 uwsgi 及 测试 uwsgi 3.1 安装 [root@crazy-acong ~]# pip3 install uwsgi 3.2 测试 uwsgi 提供 web 服务的功能 # 创建 test.py 文件def application(env, start_response): start_response('200 OK', [('Content-Type','text/html')]) return [b"Hello World"] # python3 #return ["Hello World"] # python2# 启动 uwsgi 服务[root@crazy-acong ~]# uwsgi --http :8000 --wsgi-file test.py # 查看启动进程[root@crazy-acong ~]# netstat -lnpt | grep uwsgitcp 0 0 127.0.0.1:26685 0.0.0.0:* LISTEN 22120/uwsgi tcp 0 0 0.0.0.0:8000 0.0.0.0:* LISTEN 22120/uwsgi # 在浏览器中访问 http://ip:8000 就可以看到 Hello World 字样了 3.3 将启动参数写入到配置文件中，然后进行启动 django 程序 3.3.1 创建 uwsgi 配置文件 [root@crazy-acong ~]# cd /data/django_test # 进入到 django 的主目录[root@crazy-acong django_test]# cat test-uwsgi.ini [uwsgi]# 对外提供 http 服务的端口http = :9000#the local unix socket file than commnuincate to Nginx 用于和 nginx 进行数据交互的端口socket = 127.0.0.1:8001# the base directory (full path) django 程序的主目录chdir = /data/django_test# Django's wsgi filewsgi-file = django_test/wsgi.py# maximum number of worker processesprocesses = 4#thread numbers startched in each worker processthreads = 2 #monitor uwsgi status 通过该端口可以监控 uwsgi 的负载情况stats = 127.0.0.1:9191# clear environment on exitvacuum = true# 后台运行,并输出日志daemonize = /var/log/uwsgi.log 3.3.2 通过 uwsgi 配置文件启动 django 程序 # 通过配置文件启动 django 程序[root@crazy-acong django_test]# /usr/local/bin/uwsgi test-uwsgi.ini # 在浏览器中 通过访问 http://ip:9000 可以看到发布的 django 程序 4、安装 nginx nginx 安装参考 http://www.cnblogs.com/CongZhang/p/6548570.html 5、配置 nginx 的配置文件 在 django 的主目录下创建下面的 nginx 配置文件，然后做软连接到 nginx 的配置文件目录，或者直接在 nginx 配置文件目录中添加该文件也可以 5.1 创建 nginx 配置文件 [root@crazy-acong django_test]# cat /data/django_test/django-nginx.conf # the upstream component nginx needs to connect toupstream django &#123; # server unix:///path/to/your/mysite/mysite.sock; # for a file socket server 127.0.0.1:8001; # for a web port socket (we'll use this first)&#125; # configuration of the serverserver &#123; # the port your site will be served on listen 8000; # the domain name it will serve for server_name .example.com; # substitute your machine's IP address or FQDN charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Django media location /media &#123; alias /path/to/your/mysite/media; # your Django project's media files - amend as required &#125; location /static &#123; alias /data/django_test/static; # your Django project's static files - amend as required &#125; # Finally, send all non-media requests to the Django server. location / &#123; uwsgi_pass django; include /data/django_test/uwsgi_params; # the uwsgi_params file you installed &#125;&#125; 5.2 重启nginx 服务 [root@crazy-acong django_test]# nginx -tnginx: the configuration file /data/application/nginx-1.10.3/conf/nginx.conf syntax is oknginx: configuration file /data/application/nginx-1.10.3/conf/nginx.conf test is successful[root@crazy-acong django_test]# nginx -s reload [root@crazy-acong django_test]# netstat -lnpt | grep 8000tcp 0 0 0.0.0.0:8000 0.0.0.0:* LISTEN 43492/nginx 这个时候就可以通过 http://ip:8000 访问 django 程序了，不过目前还存在一个问题，访问 http://ip:8000/admin 发现静态文件貌似没读取到，需要通过下面的方法解决静态文件的问题 6、解决 django 多 app 静态文件的问题 # 在 django 程序的 settings.py 文件中添加以下内容STATIC_ROOT = os.path.join(BASE_DIR, "static_all")# 然后通过执行该命令，将静态文件整合到一个目录中[root@crazy-acong django_test]# python3 manage.py collectstatic[root@crazy-acong django_test]# lltotal 40drwxr-xr-x 3 nginx games 4096 Mar 14 14:42 app01-rw-r--r-- 1 root root 3072 Mar 14 14:51 db.sqlite3-rw-r--r-- 1 root root 1026 Mar 14 15:18 django-nginx.confdrwxr-xr-x 3 nginx games 4096 Mar 14 15:45 django_test-rwxr-xr-x 1 nginx games 809 Mar 14 14:37 manage.pydrwxr-xr-x 2 nginx games 4096 Mar 14 14:42 staticdrwxr-xr-x 3 root root 4096 Mar 14 15:47 static_all # 此时会发现多了一个该目录，所有 app 的静态文件都整合到这一个目录中了drwxr-xr-x 2 nginx games 4096 Mar 14 14:40 templates-rw-r--r-- 1 root root 565 Mar 14 15:40 test-uwsgi.ini-rw-r--r-- 1 root root 664 Mar 14 15:28 uwsgi_params 然后需要修改 nginx 配置文件中 指向 django 静态目录的配置文件 [root@crazy-acong django_test]# cat /data/django_test/django-nginx.conf # the upstream component nginx needs to connect toupstream django &#123; # server unix:///path/to/your/mysite/mysite.sock; # for a file socket server 127.0.0.1:8001; # for a web port socket (we'll use this first)&#125; # configuration of the serverserver &#123; # the port your site will be served on listen 8000; # the domain name it will serve for server_name .example.com; # substitute your machine's IP address or FQDN charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Django media location /media &#123; alias /path/to/your/mysite/media; # your Django project's media files - amend as required &#125; location /static &#123; # 需要修改的地方在这里 alias /data/django_test/static_all; # your Django project's static files - amend as required &#125; # Finally, send all non-media requests to the Django server. location / &#123; uwsgi_pass django; include /data/django_test/uwsgi_params; # the uwsgi_params file you installed &#125;&#125; 最后重启 nginx 服务即可 [root@crazy-acong django_test]# nginx -tnginx: the configuration file /data/application/nginx-1.10.3/conf/nginx.conf syntax is oknginx: configuration file /data/application/nginx-1.10.3/conf/nginx.conf test is successful[root@crazy-acong django_test]# nginx -s reload]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os模块和sys模块的区别]]></title>
    <url>%2F2019%2F03%2F26%2Fos%E6%A8%A1%E5%9D%97%E5%92%8Csys%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[os与sys模块的官方解释如下：os: This module provides a portable way of using operating system dependent functionality. 这个模块提供了一种方便的使用操作系统函数的方法。 sys: This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter. 这个模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。 总结: os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口; sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。 os 常用方法 os.remove(‘path/filename’) 删除文件os.rename(oldname, newname) 重命名文件os.walk() 生成目录树下的所有文件名os.chdir(‘dirname’) 改变目录os.mkdir/makedirs(‘dirname’) 创建目录/多层目录os.rmdir/removedirs(‘dirname’) 删除目录/多层目录os.listdir(‘dirname’) 列出指定目录的文件os.getcwd() 取得当前工作目录os.chmod() 改变目录权限os.path.basename(‘path/filename’) 去掉目录路径，返回文件名os.path.dirname(‘path/filename’) 去掉文件名，返回目录路径os.path.join(path1[,path2[,…]]) 将分离的各部分组合成一个路径名os.path.split(‘path’) 返回( dirname(), basename())元组os.path.splitext() 返回 (filename, extension) 元组os.path.getatime\ctime\mtime 分别返回最近访问、创建、修改时间os.path.getsize() 返回文件大小os.path.exists() 是否存在os.path.isabs() 是否为绝对路径os.path.isdir() 是否为目录os.path.isfile() 是否为文件 sys 常用方法 sys.argv 命令行参数List，第一个元素是程序本身路径sys.modules.keys() 返回所有已经导入的模块列表sys.exc_info() 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息sys.exit(n) 退出程序，正常退出时exit(0)sys.hexversion 获取Python解释程序的版本值，16进制格式如：0x020403F0sys.version 获取Python解释程序的版本信息sys.maxint 最大的Int值sys.maxunicode 最大的Unicode值sys.modules 返回系统导入的模块字段，key是模块名，value是模块sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值sys.platform 返回操作系统平台名称sys.stdout 标准输出sys.stdin 标准输入sys.stderr 错误输出sys.exc_clear() 用来清除当前线程所出现的当前的或最近的错误信息sys.exec_prefix 返回平台独立的python文件安装的位置sys.byteorder 本地字节规则的指示器，big-endian平台的值是’big’,little-endian平台的值是’little’sys.copyright 记录python版权相关的东西sys.api_version 解释器的C的API版本]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进程和线程的区别]]></title>
    <url>%2F2019%2F03%2F26%2Fpython%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[进程和线程的区别进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。 线程：是进程的一个执行单元，是进程内部调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。 一个程序至少一个进程，一个进程至少一个线程。 为什么会有线程？ 每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。 线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来。进程分为单线程进程和多线程进程，单线程进程宏观来看也是线性执行过程，微观上只有单一的执行过程。多线程进程宏观是线性的，微观上多个执行操作。线程的改变只代表CPU的执行过程的改变，而没有发生进程所拥有的资源的变化。 进程线程的区别：地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程 执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。线程是处理器调度的基本单位，但是进程不是。两者均可并发执行。优缺点： 线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。 进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。 何时使用多进程，何时使用多线程？对资源的管理和保护要求高，不限制开销和效率时，使用多进程。要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年3月23日分享]]></title>
    <url>%2F2019%2F03%2F23%2F2019%E5%B9%B43%E6%9C%8823%E6%97%A5%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[这几天在做什么?​ 这几天我买了一双轮滑鞋.很久没有玩了,技术也不是很娴熟.出去转了一圈回来,路上差点摔倒,还是很危险.下次出去尽量不要直接穿鞋出去. ​ 我买这双鞋的初衷是希望自己多出去走走,锻炼身体,多出点汗.平常跑步很累也很枯燥,我不是特别喜欢这种方式的运动.鞋子买回来一天,我一路刷街,刹车,轮子已经磨损不少,很是心疼. 最近想做什么?​ 最近想换一个房子.主要是我的房子租金还是有点贵,住的楼层在七楼,没有电梯上下楼很不方便.想在公司附近找一个小的房子就行,反正是一个人生活,平时在房间里面的时间很有限. ​ 上回我想搭建一个图片服务器,网上有很多成功的第三方工具,搜索关键字就有一大堆的相关应用方案,我就不做一一推荐了.用第三方的应用目前应对我的博客是绰绰有余的.多储存,可以了解一下阿里相关FastDFS建立分布式存储服务器.杀鸡焉用牛刀,小应用可以直接使用第三方. 关于我的生活​ 找房子是一件特别要时间要精力的运动,我今天忙碌一天也没有找到很好的房子,我这边很多江西人做房子中介,精明趋利少真诚,各种服务费,折旧费,管理费,卫生费,防不甚防.房子在签合同一定要多留一个心眼,要看清每一条内容.建议朋友,同事之间多做询问,找房子这些坑大家都遇见过,相互交流一下就能避免很多坑.咸鱼,豆瓣,朋友圈资料留意一下. ​ 对于我来说,总是很难做好一个选择,真的很难,经常去选择到一个相较之下差一点的那一个选择.当我有两份工作的时候我很难选好去做哪一个.平时交谈,口音很重的我,说话看似滔滔不绝,实际也是信马由缰,乱了分寸,果然是实力它不允许我能出口成章,娓娓道来. ​ 在深圳的生活我是比较开心的,这里的气候我很喜欢,这里的空气也很清新,太空也很蓝,周末会经常聚会,一切都感觉很好.身边优秀的人很多,形形色色,林林总总,都很欣赏.这里有一片广阔的天空,我很喜欢深圳. 原图地址]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[歌曲或视频分享第一期]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%AD%8C%E6%9B%B2%E6%88%96%E8%A7%86%E9%A2%91%E5%88%86%E4%BA%AB%E7%AC%AC%E4%B8%80%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[先放出我今天推荐的歌曲: 剧情简介 · · · · · · 日本神户某个飘雪的冬日，渡边博子（中山美穗）在前未婚夫藤井树的三周年祭日上又一次悲痛到不能自已。正因为无法抑制住对已逝恋人的思念，渡边博子在其中学同学录里发现“藤井树” 在小樽市读书时的地址时，依循着寄发了一封本以为是发往天国的情书。 不想不久渡边博子竟然收到署名为“藤井树（中山美穗）”的回信，经过进一步了解，她知晓此藤井树是一个同她年纪相仿的女孩，且还是男友藤井树（柏原崇）少年时代的同班同学。为了多了解一些昔日恋人在中学时代的情况，渡边博子开始与女性藤井树书信往来。而藤井树在不断的回忆中，渐渐发现少年时代与她同名同姓的那个藤井树曾对自己藏了一腔柔情。 这部电影(Love letter)对于我自己:​ 这部电影是别人推荐给我看的,起初没怎么在意.在一个偶然的时机我打开了网页(优酷现在也有资源),之后一发不可收拾,确实很有风格.看一遍还不过瘾,过后还想再看一遍,对于我就是这样的一种感觉.像是一种甜,但是不会感觉很腻的饮品.电影情感很强烈,但是表现出来很隐忍细腻,镜头美感相当好,回味无穷. 附上一些剧照: ###附上视频: 等待广告播放完之后,右下方选择超清的选项.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>歌曲&amp;视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用命令]]></title>
    <url>%2F2019%2F03%2F18%2FMySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[参考地址: https://www.cnblogs.com/bluealine/p/7832219.html 前言​ 大多数时候, 涉及不熟悉的命令操作,一下就暴露出来自己是个菜鸡.毕竟见多识广,多练习,多理解是成长的关键.先写一点容易吸收的基本操作,其他以后边学习边更新. INSERT INTO 语句INSERT INTO 表名称 VALUES (值1, 值2,....) #插入新的行INSERT INTO Persons VALUES (&apos;Gates&apos;, &apos;Bill&apos;, &apos;Xuanwumen 10&apos;, &apos;Beijing&apos;)INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....) #指定特定字段插入 UPDATE 语句UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值UPDATE Person SET FirstName = &apos;Fred&apos; WHERE LastName = &apos;Wilson&apos; #更新某一行中间的一列UPDATE Person SET Address = &apos;Zhongshan 23&apos;, City = &apos;Nanjing&apos;WHERE LastName = &apos;Wilson&apos; #更新某一行中间的多列 DELETE 语句DELETE FROM 表名称 WHERE 列名称 = 值DELETE FROM Person WHERE LastName = &apos;Wilson&apos; #删除一行DELETE FROM table_name / DELETE * FROM table_name #删除多行 SELECT DISTINCT 语句SELECT DISTINCT 列名称 FROM 表名称SELECT DISTINCT Company FROM Orders 备份数据库 1.导出整个数据库导出文件默认是存在mysql\bin目录下 mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名​ mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 2.导出一个表 mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名​ mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 3.导出一个数据库结构 mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql​ -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 4.带语言参数导出 mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 例如，将aaa库备份到文件back_aaa中： [root@test1 root]# cd /home/data/mysql [root@test1 mysql]# mysqldump -u root -p --opt aaa &gt; back_aaa 连接MySQL 连接本地MySQL格式：mysql -u用户名 －p用户密码 # 直接用密码和用户名连接本机mysql mysql -uroot -p 连接远程MySQL1、在服务器端开启远程访问 首先进入mysql数据库，然后输入下面两个命令： grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;;flush privileges; 第一个*是数据库，可以改成允许访问的数据库名称 第二个 是数据库的表名称，代表允许访问任意的表 root代表远程登录使用的用户名，可以自定义 %代表允许任意ip登录，如果你想指定特定的IP，可以把%替换掉就可以了 password代表远程登录时使用的密码，可以自定义 flush privileges;这是让权限立即生效 2、修改my.cnf配置文件 (非常重要 位置: /etc/my.cnf) 这个是mysql的配置文件，如果你无标题文章找不到在哪里的话，可以输入find /* -name my.cnf找到 通过vim编辑该文件，找到bind-address = 127.0.0.1这一句，然后在前面加个#号注释掉，保存退出 3、重启服务 service mysql restart 4、在本地远程连接 mysql -h110.110.110.110 -u root -p 123; 加密连接远程数据库 等待另一篇文章 修改密码 格式：mysqladmin -u用户名 -p旧密码 password 新密码 mysqladmin -u root -password abc123 # 增加密码mysqladmin -u root -p abc123 password djg345 # 修改密码 增加新用户 格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” 增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令：** grant select,insert,update,delete on *.* to [email=test1@”%]test1@”%[/email]” Identified by “abc”; ​ 但增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的mysql数据库并对你的数据可以为所欲为了，解决办法见2。 增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机），这样用户即使用知道test2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。 grant select,insert,update,delete on mydb.*** to [email=test2@localhost]test2@localhost[/email] identified by “abc”; 如果你不想test2有密码，可以再打一个命令将密码消掉。 grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “”; CURD 创建表 命令：create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]); mysql&gt; create table MyClass(&gt; id int(4) not null primary key auto_increment,&gt; name char(20) not null,&gt; sex int(4) not null default &apos;0&apos;,&gt; degree double(16,2)); 除表命令：drop table &lt;表名&gt; IF EXISTS 注意：对于一个带分区的表，DROP TABLE会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。DROP TABLE还会取消与被取消的表有关联的分区定义（.par）文件。 对与不存在的表，使用IF EXISTS用于防止错误发生。当使用IF EXISTS时，对于每个不存在的表，会生成一个NOTE。 查询表中的数据命令： select &lt;字段1，字段2，...&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt; mysql&gt; select * from MyClass order by id limit 0,2;SELECT * FROM Persons WHERE Year&gt;1965SELECT * FROM Persons WHERE FirstName=&apos;Bush&apos;SELECT * FROM Persons WHERE FirstName=&apos;Thomas&apos; AND LastName=&apos;Carter&apos;SELECT * FROM Persons WHERE firstname=&apos;Thomas&apos; OR lastname=&apos;Carter&apos;SELECT * FROM Persons WHERE (FirstName=&apos;Thomas&apos; OR FirstName=&apos;William&apos;)AND LastName=&apos;Carter&apos;#我们希望从上面的 &quot;Persons&quot; 表中选取居住在以 &quot;N&quot; 开始的城市里的人SELECT * FROM Persons WHERE City LIKE &apos;N%&apos;; #提示：&quot;%&quot; 可用于定义通配符（模式中缺少的字母）。#接下来，我们希望从 &quot;Persons&quot; 表中选取居住在以 &quot;g&quot; 结尾的城市里的人：SELECT * FROM Persons WHERE City LIKE &apos;%g&apos;; 这里以后再补充补充:最简单也是用的最多,实现多样化的地方,性能各有差异 表插入数据命令：insert into &lt;表名&gt; [( &lt;字段名1&gt;[,..&lt;字段名n &gt; ])] values ( 值1 )[, ( 值n )] insert into MyClass values(1,&apos;Tom&apos;,96.45),(2,&apos;Joan&apos;,82.99), (2,&apos;Wang&apos;, 96.59); 注意：insert into每次只能向表中插入一条记录。 修改表中数据语法：update 表名 set 字段=新值,… where 条件 mysql&gt; UPDATE persondata SET age=age+1;mysql&gt; UPDATE persondata SET age=age*2, age=age+1; UPDATE [LOW_PRIORITY] [IGNORE] tbl_name SET col_name1=expr1 [, col_name2=expr2 ...] [WHERE where_definition] [ORDER BY ...] [LIMIT row_count] # 单表 UPDATE [LOW_PRIORITY] [IGNORE] table_references SET col_name1=expr1 [, col_name2=expr2 ...] [WHERE where_definition] ＃ 多表 增加字段命令：**alter table** 表名 **add**字段 类型 其他; mysql&gt; alter table MyClass add passtest int(4) default '0'mysql&gt; alter table employee add index emp_name (name);mysql&gt; alter table employee add primary key(id); 加索引mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]);例子：mysql&gt; alter table employee add index emp_name (name); 加主关键字的索引mysql&gt; alter table 表名 add primary key (字段名);例子：mysql&gt; alter table employee add primary key(id); 加唯一限制条件的索引mysql&gt; alter table 表名 add unique 索引名 (字段名);例子：mysql&gt; alter table employee add unique emp_name2(cardnumber); 删除某个索引mysql&gt; alter table 表名 drop index 索引名;例子： mysql&gt;alter table employee drop index emp_name; 增加字段：mysql&gt; ALTER TABLE table_name ADD field_name field_type; 修改原字段名称及类型：mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 删除字段：MySQL ALTER TABLE table_name DROP field_name; 修改表名命令：rename table 原表名 to 新表名; mysql&gt; rename table MyClass to YouClass; 当你执行 RENAME 时，你不能有任何锁定的表或活动的事务。你同样也必须有对原初表的 ALTER 和 DROP 权限，以及对新表的 CREATE 和 INSERT 权限。 如果在多表更名中，MySQL 遭遇到任何错误，它将对所有被更名的表进行倒退更名，将每件事物退回到最初状态。 RENAME TABLE 在 MySQL 3.23.23 中被加入。 建库和建表的实例1drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER( id int(3) auto_increment not null primary key, name char(10) not null, address varchar(50) default ‘深圳’, year date); //建表结束//以下为插入字段insert into teacher values(”,’allen’,&apos;大连一中’,&apos;1976-10-10′);insert into teacher values(”,’jack’,&apos;大连二中’,&apos;1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。1、你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\下，并在DOS状态进入目录,然后键入以下命令：​ mysql -uroot -p密码 &lt; c:\\school.sql如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 2、或者进入命令行后使用 mysql&gt; source c:\\school.sql; 也可以将school.sql文件导入数据库中。 建库和建表的实例2drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER( id int(3) auto_increment not null primary key, name char(10) not null, address varchar(50) default &apos;&apos;深圳&apos;&apos;, year date); //建表结束//以下为插入字段insert into teacher values(&apos;&apos;&apos;&apos;,&apos;&apos;glchengang&apos;&apos;,&apos;&apos;深圳一中&apos;&apos;,&apos;&apos;1976-10-10&apos;&apos;);insert into teacher values(&apos;&apos;&apos;&apos;,&apos;&apos;jack&apos;&apos;,&apos;&apos;深圳一中&apos;&apos;,&apos;&apos;1975-12-23&apos;&apos;); 注：在建表中1、将ID设为长度为3的数字字段:int(3)；并让它每个记录自动加一:auto_increment；并不能为空:not null；而且让他成为主字段primary key。 2、将NAME设为长度为10的字符字段 3、将ADDRESS设为长度50的字符字段，而且缺省值为深圳。 4、将YEAR设为日期字段。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年3月17日分享]]></title>
    <url>%2F2019%2F03%2F17%2F2019%E5%B9%B43%E6%9C%8817%E6%97%A5%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[这几天在做什么?​ 我最近买了一个域名:jxiaof.com. ​ 买这个域名的初衷主要是为了把我自己的博客搭建起来.也正是这个原由,我选了这个看上去很难记忆的域名,其实江小凡的首字母缩写,当然xiao这几个字母很容记住并很容易打出来的.我一开始想选择jiangxiaofan.com作为我的个人博客域名,但是……..名字这么好听,当然被别人先一步就注册了,我看了一下2015年这个域名就被别人注册了.当然时间仓促,想象力不够丰富,不了解的东西很多,所以没有选出更好的更牛X的域名来. ​ 我这个域名是在https://www.namesilo.com注册的,一个美国公司.一年的费用是5.99$ (目前新域名只能购买一年使用权). 最近想做什么?​ 最近想找个女朋友! ​ 想搭建一个图片存储服务器.目前还没有成功,所以我找了很多资料,有很多方法都不错.现在用的最轻松的是QQ空间相册,哈哈哈哈.毕竟中国大多数人的相册服务器.也有很多收费免收费的工具.反正做着玩. 关于我的生活​ 我这两天基本没有出门,除开我下楼吃饭买点水果和饮用水,一直都独自在房间里. ​ 我这样说并不是我平时都是这样的生活,仅仅是这两天没有出门.大多数的时候周末我都会出去.我这两天里我只是恰好想克服一下自己学习东西的畏惧感.我平时工作留给我很多富余的时间,我一般会出去走一走,看个电视或电影,聊天,玩游戏.唯独我不想把时间留给电脑,看文档,敲代码.真的人生很短,怎么能天天看代码呢!一不小心又几个月的时间过去,自己就更不能安静下来学习新东西.很烦,很烦. ​]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化第二篇]]></title>
    <url>%2F2019%2F03%2F15%2FMySQL%E4%BC%98%E5%8C%96%E7%AC%AC%E4%BA%8C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1、选取最适用的字段属性MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。 例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。 另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。 ####2、使用连接（JOIN）来代替子查询(Sub-Queries)MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示： DELETE FROM customerinfoWHERE CustomerID NOT IN (SELECT CustomerID FROM salesinfo) 使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）..替代。例如，假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成： SELECT * FROM customerinfoWHERE CustomerID NOT IN (SELECTC ustomerID FROM salesinfo) 如果使用连接（JOIN）..来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下： SELECT * FROM customerinfoLEFT JOIN salesinfo ON customerinfo.CustomerID=salesinfo.CustomerIDWHERE salesinfo.CustomerID ISNULL 连接（JOIN）..之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。 3、使用联合(UNION)来代替手动创建的临时表MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。 SELECT Name,Phone FROM client UNIONSELECT Name,BirthDate FROM author UNIONSELECT Name,Supplier FROM product 4、事务尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。 BEGIN; INSERT INTO salesinfo SET CustomerID=14; UPDATE inventory SET Quantity=11 WHERE item='book'; COMMIT; 事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。 5、锁定表尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。 其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。 LOCK TABLE inventory WRITE SELECT Quantity FROM inventory WHERE Item='book';...UPDATE inventory SET Quantity=11 WHERE Item='book'; UNLOCKTABLES 这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。 6、使用外键锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。 例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都不会被更新或插入到salesinfo中。 CREATE TABLE customerinfo(CustomerIDINT NOT NULL,PRIMARYKEY(CustomerID))TYPE=INNODB;CREATE TABLE salesinfo( SalesIDNT NOT NULL,CustomerIDINT NOT NULL, PRIMARYKEY(CustomerID,SalesID),FOREIGNKEY(CustomerID) REFERENCES customerinfo(CustomerID) ON DELETE CASCADE)TYPE=INNODB; 注意例子中的参数“ON DELETE CASCADE”。该参数保证当customerinfo表中的一条客户记录被删除的时候，salesinfo表中所有与该客户相关的记录也会被自动删除。如果要在MySQL中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表InnoDB类型。该类型不是MySQL表的默认类型。定义的方法是在CREATETABLE语句中加上TYPE=INNODB。如例中所示。 7、使用索引索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。 那该对哪些字段建立索引呢？ 一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况 例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。 8、优化的查询语句绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用。 下面是应该注意的几个方面。 首先，最好是在相同类型的字段间进行比较的操作。 在MySQL3.23版之前，这甚至是一个必须的条件。例如不能将一个建有索引的INT字段和BIGINT字段进行比较；但是作为特殊的情况，在CHAR类型的字段和VARCHAR类型字段的字段大小相同的时候，可以将它们进行比较。 其次，在建有索引的字段上尽量不要使用函数进行操作。 例如，在一个DATE类型的字段上使用YEAE()函数时，将会使索引不能发挥应有的作用。所以，下面的两个查询虽然返回的结果一样，但后者要比前者快得多。 第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的。 例如下面的查询将会比较表中的每一条记录。 SELECT * FROM booksWHERE name like"MySQL%" 但是如果换用下面的查询，返回的结果一样，但速度就要快上很多： SELECT * FROM booksWHERE name＞="MySQL" andname ＜"MySQM" 最后，应该注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库优化]]></title>
    <url>%2F2019%2F03%2F15%2Fmysql%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[#MySQL数据库优化总结 ​ 对于一个以数据为中心的应用，数据库的好坏直接影响到程序的性能，因此数据库性能至关重要。一般来说，要保证数据库的效率，要做好以下四个方面的工作：数据库设计、sql语句优化、数据库参数配置、恰当的硬件资源和操作系统，这个顺序也表现了这四个工作对性能影响的大小。下面我们逐个阐明： ​ 一、数据库设计 适度的反范式,注意是适度的 我们都知道三范式，基于三范式建立的模型是最有效保存数 据的方式，也是最容易扩展的模式。我们在开发应用程序时，设计的数据库要最大程度的遵守三范式，特别是对于OLTP型的系统，三范式是必须遵守的规则。当 然，三范式最大的问题在于查询时通常需要join很多表，导致查询效率很低。所以有时候基于性能考虑，我们需要有意的违反三范式，适度的做冗余，以达到提 高查询效率的目的。注意这里的反范式是适度的，必须为这种做法提供充分的理由。下面就是一个糟糕的实例： 在这里，为了提高学生活动记录的检索效率，把单位名称冗余到学生活动记录表里。单位信息有500条记录，而学生活动记录在一年内大概有200万数据量。 如果学生活动记录表不冗余这个单位名称字段，只包含三个int字段和一个timestamp字段，只占用了16字节，是一个很小的表。而冗余了一个 varchar(32)的字段后则是原来的3倍，检索起来相应也多了这么多的I/O。而且记录数相差悬殊，500 VS 2000000 ，导致更新一个单位名称还要更新4000条冗余记录。由此可见，这个冗余根本就是适得其反。 下面这个冗余就很好 可以看到，[学生考试总分]是冗余的，这个分数完全可以通过[得分情况]汇总得到。在【学生考试总分】里，一次考试一个学生只有一条记录，而在【得分情 况】里，一个学生针对试卷里一个小题的一个小问一条记录，粗略的算一下比例大概是1：100。而且判卷子得分是不会轻易变的，更新的频率不高，所以说这个 冗余是比较好的。 ​ 适当建立索引 说起提高数据库性能，索引是最物美价廉的东西了。不用加内存，不用改程序，不用调sql，只要执行个正确的’create index’，查询速度就可能提高百倍千倍，这可真有诱惑力。可是天下没有免费的午餐，查询速度的提高是以插入、更新、删除的速度为代价的，这些写操作，增加了大量的I/O。由于索引的存储结构不同于表的存储，一个表的索引所占空间比数据所占空间还大的情况经常发生。这意味着我们在写数据库的时候做了很多额外的工作，而这个工作只是为了提高读的效率。因此，我们建立一个索引，必须保证这个索引不会“亏本”。一般需要遵守这样的规则： 索引的字段必须是经常作为查询条件的字段; 如果索引多个字段，第一个字段要是经常作为查询条件的。如果只有第二个字段作为查询条件，这个索引不会起到作用; 索引的字段必须有足够的区分度; Mysql 对于长字段支持前缀索引; 对表进行水平划分 如果一个表的记录数太多了，比如上千万条，而且需要经常检索，那么我们就有必要化整为零了。如果我拆成100个表，那么每个表只有10万条记录。当然这 需要数据在逻辑上可以划分。一个好的划分依据，有利于程序的简单实现，也可以充分利用水平分表的优势。比如系统界面上只提供按月查询的功能，那么把表按月 拆分成12个，每个查询只查询一个表就够了。如果非要按照地域来分，即使把表拆的再小，查询还是要联合所有表来查，还不如不拆了。所以一个好的拆分依据是 最重要的。 这里有个比较好的实例 每个学生做过的题都记录在这个表里，包括对题和错题。每个题会对应一个或多个知识点，我们需要根据错题来分析学生在哪个知识点上掌握的不足。这个表很容 易达到千万级，迫切需要拆分，那么根据什么来拆呢?从需求上看，无论是老师还是学生，最终会把焦点落在一个学生的身上。学生会关心自己，老师会关心自己班 的学生。而且每个学科的知识点是不同的。所以我们很容易想到，联合学科和知识点两个字段来拆分这个表。这样拆下来，每个表大概2万条数据，检索效率非常 高。 ​ 对表进行垂直划分 有些表记录数并不多，可能也就2、3万条，但是字段却很长，表占用空间很大，检索表时需要执行大量I/O，严重降低了性能。这个时候需要把大的字段拆分到另一个表，并且该表与原表是一对一的关系。 【试题内容】、【答案信息】两个表，最初是作为几个字段添加到【试题信息】里的，可以看到试题内容和答案这两个字段很长，在表里有3万记录时，表已经占 了1G的空间，在列试题列表时非常慢。经过分析，发现系统很多时候是根据【册】、【单元】、类型、类别、难易程度等查询条件，分页显示试题详细内容。而每 次检索都是这几个表做join，每次要扫描一遍1G的表，很郁闷啊。我们完全可以把内容和答案拆分成另一个表，只有显示详细内容的时候才读这个大表，由此 就产生了【试题内容】、【答案信息】两个表。 ​ 选择适当的字段类型，特别是主键 选择字段的一般原则是保小不保大，能用占用字节小的字段就不用大字段。比如主键， 我们强烈建议用自增类型，不用guid，为什么?省空间啊?空间是什么?空间就是效率!按4个字节和按32个字节定位一条记录，谁快谁慢太明显了。涉及到 几个表做join时，效果就更明显了。值得一提的是，datetime和timestamp，datetime占用8个字节，而timestamp占用4 个字节，只用了一半，而timestamp表示的范围是1970—2037，对于大多数应用，尤其是记录什么考试时间，登录时间这类信息，绰绰有余啊。 文件、图片等大文件用文件系统存储，不用数据库 不用多说，铁律!!!数据库只存储路径。 外键表示清楚，方便建立索引 我们都知道，在powerdesigner里为两个实体建立关系，生成物理模型时会自动给外键建立索引。所以我们不要怕建立关系把线拉乱，建立个ShortCut就好了。 掌握表的写入时机 在库模式相同的情况下，如何使用数据库也对性能有着重要作用。同样是写入一个表，先写和后写对后续的操作会产生很大影响。例如在上面提到的适度冗余里的例子， 我们最初的目的是记录考生的总分，以达到提高检索效率的目的，也就是在录入成绩时写入这个表。在需求里有这样的要求：列出本次考试的所有学生成绩，没有 录入成绩的也显示该学生名称，只是总分显示为空。这个查询就需要用【学生信息】left outer join 【学生考试总分信息】，大家都知道outer join 的效率比join是要低的，为了避免这个问题，我们就在布置考试的时候写入这个表，把所有学生都插入进去，分数都是null，这样一来我们就可以用 join达到这个效果了。而且还有这样的好处：在某次考试中，安排了一个班所有学生考试，所有学生都录入了成绩。现在班里转来一个新生，那么在此时如果查 询学生成绩，就会列出这个新生，结果是未录入成绩，这显然是不对的。如果在安排的时候就写入，就可以记录下该次考试中实际的考生了，这个表的作用，也就不 知是冗余了。 宁可集中批量操作，避免频繁读写 系统里包含了积分部分，学生和老师通过系统做了操作都可以获得积分，而且积分规 则很复杂，限制每类操作获得积分不同，每人每天每类积分都有上限。比如登录，一次登录就可以获得1分，但是不管你登录多少次，一天只能累积一个登录积分。 这个还是简单的，有的积分很变态，比如老师积分中有一类是看老师判作业的情况，规则是：老师判了作业，发现学生有错的，学生改过了，老师再判，如果这时候 学生都对了，就给老师加分，如果学生还是错的，那就接着改，知道学生都改对了，老师都判完了，才能给老师加分。如果用程序来处理，很可能每个功能都会额外 的写一堆代码来处理这个鸡肋似的积分。不仅编程的同事干活找不到重点，还平白给数据库带来了很大的压力。经过和需求人员的讨论，确定积分没有必要实时累 积，于是我们采取后台脚本批量处理的方式。夜深人静的时候，让机器自己玩去吧。 这个变态的积分规则用批处理读出来是这样的： select person_id, @semester_id, 301003, 0, @one_marks, assign_date, @one_marks from hom_assignmentinfo ha, hom_assign_class hac where ha.assignment_id = hac.assignment_id and ha.assign_date between @time_begin and @time_end and ha.assignment_id not in ( select haa.assignment_id from hom_assignment_appraise haa, hom_check_assignment hca where haa.appraise_id = hca.appraise_id and haa.if_submit=1 and ( (hca.recheck_state = 3004001 and hca.check_result in (3003002, 3003003) ) or (hca.recheck_state = 3004002 and hca.recheck_result in (3003002, 3003003)) ) ) and ha.assignment_id not in ( select assignment_id from hom_assignment_appraise where if_submit=0 and result_type = 0 ) and ha.assignment_id in ( select haa.assignment_id from hom_assignment_appraise haa, hom_check_assignment hca where haa.appraise_id = hca.appraise_id and haa.if_submit=1 and hca.check_result in (3003002, 3003003) ); 这还只是个中间过程，这要是用程序实时处理，即使编程人员不罢工，数据库也会歇了。 选择合适的引擎 Mysql提供了很多种引擎，我们用的最多的是myisam，innodb，memory这三类。官方手册上说道myisqm比innodb的读速度要 快，大概是3倍。不过书不能尽信啊，《OreIlly.High.Performance.Mysql》这本书里提到了myisam和innodb的比 较，在测试中myisam的表现还不及innodb。至于memory，哈哈，还是比较好用的。在批处理种作临时表是个不错的选择(如果内存够大)。在我的一个批处理中，速度比近乎1：10。 ​ 二、SQL语句优化 Sql语句优化工具 ·慢日志 如果发现系统慢了，又说不清楚是哪里慢，那么就该用这个工具了。只需要为mysql配置参数，mysql会自己记录下来慢的sql语句。配置很简单，参数文件里配置： slow_query_log=d:/slow.txt long_query_time = 2 就可以在d:/slow.txt里找到执行时间超过2秒的语句了，根据这个文件定位问题吧。 ·mysqldumpslow.pl 慢日志文件可能会很大，让人去看是很难受的事。这时候我们可以通过mysql自带的工具来分析。这个工具可以格式化慢日志文件，对于只是参数不同的语句 会归类类并，比如有两个语句select from a where id=1 和select from a where id=2，经过这个工具整理后就只剩下select * from a where id=N，这样读起来就舒服多了。而且这个工具可以实现简单的排序，让我们有的放矢。 Explain 现在我们已经知道是哪个语句慢了，那么它为什么慢呢?看看mysql是怎么执行的吧，用explain可以看到mysql执行计划，下面的用法来源于手册 EXPLAIN语法(获取SELECT相关信息) EXPLAIN [EXTENDED] SELECT select_options EXPLAIN语句可以用作DESCRIBE的一个同义词，或获得关于MySQL如何执行SELECT语句的信息： · EXPLAIN tbl_name是DESCRIBE tbl_name或SHOW COLUMNS FROM tbl_name的一个同义词。 · 如果在SELECT语句前放上关键词EXPLAIN，MySQL将解释它如何处理SELECT，提供有关表如何联接和联接的次序。 该节解释EXPLAIN的第2个用法。 借助于EXPLAIN，可以知道什么时候必须为表加入索引以得到一个使用索引来寻找记录的更快的SELECT。 如果由于使用不正确的索引出现了问题，应运行ANALYZE TABLE更新表的统计(例如关键字集的势)，这样会影响优化器进行的选择。 还可以知道优化器是否以一个最佳次序联接表。为了强制优化器让一个SELECT语句按照表命名顺序的联接次序，语句应以STRAIGHT_JOIN而不只是SELECT开头。 EXPLAIN为用于SELECT语句中的每个表返回一行信息。表以它们在处理查询过程中将被MySQL读入的顺序被列出。MySQL用一遍扫描多次联 接(single-sweep multi-join)的方式解决所有联接。这意味着MySQL从第一个表中读一行，然后找到在第二个表中的一个匹配行，然后在第3个表中等等。当所有的 表处理完后，它输出选中的列并且返回表清单直到找到一个有更多的匹配行的表。从该表读入下一行并继续处理下一个表。 当使用EXTENDED关键字时，EXPLAIN产生附加信息，可以用SHOW WARNINGS浏览。该信息显示优化器限定SELECT语句中的表和列名，重写并且执行优化规则后SELECT语句是什么样子，并且还可能包括优化过程的其它注解。 如果什么都做不了，试试全索引扫描 如果一个语句实在不能优化了，那么还有一个方法可以试试：索引覆盖。 如果一个语句可以从索引上获取全部数据，就不需要通过索引再去读表，省了很多I/O。比如这样一个表 如果我要统计每个学生每道题的得分情况，我们除了要给每个表的主键外键建立索引，还要对【得分情况】的实际得分字段索引，这样，整个查询就可以从索引得到数据了。 三、数据库参数配置 ​ 最重要的参数就是内存，我们主要用的innodb引擎，所以下面两个参数调的很大 # Additional memory pool that is used by InnoDB to store metadata# information. If InnoDB requires more memory for this purpose it will# start to allocate it from the OS. As this is fast enough on most# recent operating systems, you normally do not need to change this# value. SHOW INNODB STATUS will display the current amount used.innodb_additional_mem_pool_size = 64M# InnoDB, unlike MyISAM, uses a buffer pool to cache both indexes and# row data. The bigger you set this the less disk I/O is needed to# access data in tables. On a dedicated database server you may set this# parameter up to 80% of the machine physical memory size. Do not set it# too large, though, because competition of the physical memory may# cause paging in the operating system. Note that on 32bit systems you# might be limited to 2-3.5G of user level memory per process, so do not# set it too high.innodb_buffer_pool_size = 5G 对于myisam，需要调整key_buffer_size 当然调整参数还是要看状态，用show status语句可以看到当前状态，以决定改调整哪些参数 Cretated_tmp_disk_tables 增加tmp_table_size Handler_read_key 高表示索引正确 Handler_read_rnd高表示索引不正确 Key_reads/Key_read_requests 应小于0.01 计算缓存损失率，增加Key_buffer_size Opentables/Open_tables 增加table_cache select_full_join 没有实用索引的链接的数量。如果不为0，应该检查索引。 select_range_check 如果不为0，该检查表索引。 sort_merge_passes 排序算法已经执行的合并的数量。如果该值较大，应增加sort_buffer_size table_locks_waited 不能立即获得的表的锁的次数，如果该值较高，应优化查询 Threads_created 创建用来处理连接的线程数。如果Threads_created较大，要增加 thread_cache_size值。 缓存访问率的计算方法Threads_created/Connections。 ​ 四、合理的硬件资源和操作系统 如果你的机器内存超过4G，那么毋庸置疑应当采用64位操作系统和64位mysql 读写分离 如果数据库压力很大，一台机器支撑不了，那么可以用mysql复制实现多台机器同步，将数据库的压力分散。 Master Slave1 Slave2 Slave3 主库master用来写入，slave1—slave3都用来做select，每个数据库分担的压力小了很多。 要实现这种方式，需要程序特别设计，写都操作master，读都操作slave，给程序开发带来了额外负担。当然目前已经有中间件来实现这个代理，对程 序来读写哪些数据库是透明的。官方有个mysql-proxy，但是还是alpha版本的。新浪有个amobe for mysql，也可达到这个目的，结构如下 使用方法可以看amobe的手册。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Categories]]></title>
    <url>%2F2019%2F03%2F14%2Fcategories%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first blogs]]></title>
    <url>%2F2019%2F03%2F14%2FMy-first-blogs%2F</url>
    <content type="text"><![CDATA[HELLO WORLD今天我打算开通我自己的个人博客这个博客主要为静态页面展示.今天先这样,接下来我会把我的一些工作和生活分享在这个博客中. DEMO下面是我手写的一个快速排序算法: quick_sort=lambda array:array if len(array)&lt;=1 else quick_sort([i for i in array[1:] if i&lt;=array[0]]) + [array[0]] + quick_sort([i for i in array[1:] if i &gt; array[0]]) THE END]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
</search>
