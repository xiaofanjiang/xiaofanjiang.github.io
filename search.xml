<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[os模块和sys模块的区别]]></title>
    <url>%2F2019%2F03%2F26%2Fos%E6%A8%A1%E5%9D%97%E5%92%8Csys%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[os与sys模块的官方解释如下： os: This module provides a portable way of using operating system dependent functionality. 这个模块提供了一种方便的使用操作系统函数的方法。 sys: This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter. 这个模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。 总结: os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口; sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。 os 常用方法 os.remove(‘path/filename’) 删除文件os.rename(oldname, newname) 重命名文件os.walk() 生成目录树下的所有文件名os.chdir(‘dirname’) 改变目录os.mkdir/makedirs(‘dirname’) 创建目录/多层目录os.rmdir/removedirs(‘dirname’) 删除目录/多层目录os.listdir(‘dirname’) 列出指定目录的文件os.getcwd() 取得当前工作目录os.chmod() 改变目录权限os.path.basename(‘path/filename’) 去掉目录路径，返回文件名os.path.dirname(‘path/filename’) 去掉文件名，返回目录路径os.path.join(path1[,path2[,…]]) 将分离的各部分组合成一个路径名os.path.split(‘path’) 返回( dirname(), basename())元组os.path.splitext() 返回 (filename, extension) 元组os.path.getatime\ctime\mtime 分别返回最近访问、创建、修改时间os.path.getsize() 返回文件大小os.path.exists() 是否存在os.path.isabs() 是否为绝对路径os.path.isdir() 是否为目录os.path.isfile() 是否为文件 sys 常用方法 sys.argv 命令行参数List，第一个元素是程序本身路径sys.modules.keys() 返回所有已经导入的模块列表sys.exc_info() 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息sys.exit(n) 退出程序，正常退出时exit(0)sys.hexversion 获取Python解释程序的版本值，16进制格式如：0x020403F0sys.version 获取Python解释程序的版本信息sys.maxint 最大的Int值sys.maxunicode 最大的Unicode值sys.modules 返回系统导入的模块字段，key是模块名，value是模块sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值sys.platform 返回操作系统平台名称sys.stdout 标准输出sys.stdin 标准输入sys.stderr 错误输出sys.exc_clear() 用来清除当前线程所出现的当前的或最近的错误信息sys.exec_prefix 返回平台独立的python文件安装的位置sys.byteorder 本地字节规则的指示器，big-endian平台的值是’big’,little-endian平台的值是’little’sys.copyright 记录python版权相关的东西sys.api_version 解释器的C的API版本]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进程和线程的区别]]></title>
    <url>%2F2019%2F03%2F26%2Fpython%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[进程和线程的区别 进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。 线程：是进程的一个执行单元，是进程内部调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。 一个程序至少一个进程，一个进程至少一个线程。 为什么会有线程？ 每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。 线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来。进程分为单线程进程和多线程进程，单线程进程宏观来看也是线性执行过程，微观上只有单一的执行过程。多线程进程宏观是线性的，微观上多个执行操作。线程的改变只代表CPU的执行过程的改变，而没有发生进程所拥有的资源的变化。 进程线程的区别： 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程 执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。线程是处理器调度的基本单位，但是进程不是。两者均可并发执行。优缺点： 线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。 进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。 何时使用多进程，何时使用多线程？ 对资源的管理和保护要求高，不限制开销和效率时，使用多进程。要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年3月23日分享]]></title>
    <url>%2F2019%2F03%2F23%2F2019%E5%B9%B43%E6%9C%8823%E6%97%A5%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[这几天在做什么? ​ 这几天我买了一双轮滑鞋.很久没有玩了,技术也不是很娴熟.出去转了一圈回来,路上差点摔倒,还是很危险.下次出去尽量不要直接穿鞋出去. ​ 我买这双鞋的初衷是希望自己多出去走走,锻炼身体,多出点汗.平常跑步很累也很枯燥,我不是特别喜欢这种方式的运动.鞋子买回来一天,我一路刷街,刹车,轮子已经磨损不少,很是心疼. 最近想做什么? ​ 最近想换一个房子.主要是我的房子租金还是有点贵,住的楼层在七楼,没有电梯上下楼很不方便.想在公司附近找一个小的房子就行,反正是一个人生活,平时在房间里面的时间很有限. ​ 上回我想搭建一个图片服务器,网上有很多成功的第三方工具,搜索关键字就有一大堆的相关应用方案,我就不做一一推荐了.用第三方的应用目前应对我的博客是绰绰有余的.多储存,可以了解一下阿里相关FastDFS建立分布式存储服务器.杀鸡焉用牛刀,小应用可以直接使用第三方. 关于我的生活 ​ 找房子是一件特别要时间要精力的运动,我今天忙碌一天也没有找到很好的房子,我这边很多江西人做房子中介,精明趋利少真诚,各种服务费,折旧费,管理费,卫生费,防不甚防.房子在签合同一定要多留一个心眼,要看清每一条内容.建议朋友,同事之间多做询问,找房子这些坑大家都遇见过,相互交流一下就能避免很多坑.咸鱼,豆瓣,朋友圈资料留意一下. ​ 对于我来说,总是很难做好一个选择,真的很难,经常去选择到一个相较之下差一点的那一个选择.当我有两份工作的时候我很难选好去做哪一个.平时交谈,口音很重的我,说话看似滔滔不绝,实际也是信马由缰,乱了分寸,果然是实力它不允许我能出口成章,娓娓道来. ​ 在深圳的生活我是比较开心的,这里的气候我很喜欢,这里的空气也很清新,太空也很蓝,周末会经常聚会,一切都感觉很好.身边优秀的人很多,形形色色,林林总总,都很欣赏.这里有一片广阔的天空,我很喜欢深圳. 原图地址]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[歌曲或视频分享第一期]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%AD%8C%E6%9B%B2%E6%88%96%E8%A7%86%E9%A2%91%E5%88%86%E4%BA%AB%E7%AC%AC%E4%B8%80%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[先放出我今天推荐的歌曲: 剧情简介 · · · · · · 日本神户某个飘雪的冬日，渡边博子（中山美穗）在前未婚夫藤井树的三周年祭日上又一次悲痛到不能自已。正因为无法抑制住对已逝恋人的思念，渡边博子在其中学同学录里发现“藤井树” 在小樽市读书时的地址时，依循着寄发了一封本以为是发往天国的情书。 不想不久渡边博子竟然收到署名为“藤井树（中山美穗）”的回信，经过进一步了解，她知晓此藤井树是一个同她年纪相仿的女孩，且还是男友藤井树（柏原崇）少年时代的同班同学。为了多了解一些昔日恋人在中学时代的情况，渡边博子开始与女性藤井树书信往来。而藤井树在不断的回忆中，渐渐发现少年时代与她同名同姓的那个藤井树曾对自己藏了一腔柔情。 这部电影(Love letter)对于我自己: ​ 这部电影是别人推荐给我看的,起初没怎么在意.在一个偶然的时机我打开了网页(优酷现在也有资源),之后一发不可收拾,确实很有风格.看一遍还不过瘾,过后还想再看一遍,对于我就是这样的一种感觉.像是一种甜,但是不会感觉很腻的饮品.电影情感很强烈,但是表现出来很隐忍细腻,镜头美感相当好,回味无穷. 附上一些剧照: ###附上视频: 等待广告播放完之后,右下方选择超清的选项.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>歌曲&amp;视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用命令]]></title>
    <url>%2F2019%2F03%2F18%2FMySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[参考地址: https://www.cnblogs.com/bluealine/p/7832219.html 前言 ​ 大多数时候, 涉及不熟悉的命令操作,一下就暴露出来自己是个菜鸡.毕竟见多识广,多练习,多理解是成长的关键.先写一点容易吸收的基本操作,其他以后边学习边更新. INSERT INTO 语句 INSERT INTO 表名称 VALUES (值1, 值2,....) #插入新的行INSERT INTO Persons VALUES (&apos;Gates&apos;, &apos;Bill&apos;, &apos;Xuanwumen 10&apos;, &apos;Beijing&apos;)INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....) #指定特定字段插入 UPDATE 语句 UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值UPDATE Person SET FirstName = &apos;Fred&apos; WHERE LastName = &apos;Wilson&apos; #更新某一行中间的一列UPDATE Person SET Address = &apos;Zhongshan 23&apos;, City = &apos;Nanjing&apos;WHERE LastName = &apos;Wilson&apos; #更新某一行中间的多列 DELETE 语句 DELETE FROM 表名称 WHERE 列名称 = 值DELETE FROM Person WHERE LastName = &apos;Wilson&apos; #删除一行DELETE FROM table_name / DELETE * FROM table_name #删除多行 SELECT DISTINCT 语句 SELECT DISTINCT 列名称 FROM 表名称SELECT DISTINCT Company FROM Orders 备份数据库 1.导出整个数据库导出文件默认是存在mysql\bin目录下 mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名​ mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 2.导出一个表 mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名​ mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 3.导出一个数据库结构 mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql​ -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 4.带语言参数导出 mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 例如，将aaa库备份到文件back_aaa中： [root@test1 root]# cd /home/data/mysql [root@test1 mysql]# mysqldump -u root -p --opt aaa &gt; back_aaa 连接MySQL 连接本地MySQL 格式：mysql -u用户名 －p用户密码 # 直接用密码和用户名连接本机mysql mysql -uroot -p 连接远程MySQL 1、在服务器端开启远程访问 首先进入mysql数据库，然后输入下面两个命令： grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;;flush privileges; 第一个*是数据库，可以改成允许访问的数据库名称 第二个 是数据库的表名称，代表允许访问任意的表 root代表远程登录使用的用户名，可以自定义 %代表允许任意ip登录，如果你想指定特定的IP，可以把%替换掉就可以了 password代表远程登录时使用的密码，可以自定义 flush privileges;这是让权限立即生效 2、修改my.cnf配置文件 (非常重要 位置: /etc/my.cnf) 这个是mysql的配置文件，如果你无标题文章找不到在哪里的话，可以输入find /* -name my.cnf找到 通过vim编辑该文件，找到bind-address = 127.0.0.1这一句，然后在前面加个#号注释掉，保存退出 3、重启服务 service mysql restart 4、在本地远程连接 mysql -h110.110.110.110 -u root -p 123; 加密连接远程数据库 等待另一篇文章 修改密码 格式：mysqladmin -u用户名 -p旧密码 password 新密码 mysqladmin -u root -password abc123 # 增加密码mysqladmin -u root -p abc123 password djg345 # 修改密码 增加新用户 格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” 增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令：** grant select,insert,update,delete on *.* to [email=test1@”%]test1@”%[/email]” Identified by “abc”; ​ 但增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的mysql数据库并对你的数据可以为所欲为了，解决办法见2。 增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机），这样用户即使用知道test2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。 grant select,insert,update,delete on mydb.*** to [email=test2@localhost]test2@localhost[/email] identified by “abc”; 如果你不想test2有密码，可以再打一个命令将密码消掉。 grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “”; CURD 创建表 命令：create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]); mysql&gt; create table MyClass(&gt; id int(4) not null primary key auto_increment,&gt; name char(20) not null,&gt; sex int(4) not null default &apos;0&apos;,&gt; degree double(16,2)); 除表 命令：drop table &lt;表名&gt; IF EXISTS 注意：对于一个带分区的表，DROP TABLE会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。DROP TABLE还会取消与被取消的表有关联的分区定义（.par）文件。 对与不存在的表，使用IF EXISTS用于防止错误发生。当使用IF EXISTS时，对于每个不存在的表，会生成一个NOTE。 查询表中的数据 命令： select &lt;字段1，字段2，...&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt; mysql&gt; select * from MyClass order by id limit 0,2;SELECT * FROM Persons WHERE Year&gt;1965SELECT * FROM Persons WHERE FirstName=&apos;Bush&apos;SELECT * FROM Persons WHERE FirstName=&apos;Thomas&apos; AND LastName=&apos;Carter&apos;SELECT * FROM Persons WHERE firstname=&apos;Thomas&apos; OR lastname=&apos;Carter&apos;SELECT * FROM Persons WHERE (FirstName=&apos;Thomas&apos; OR FirstName=&apos;William&apos;)AND LastName=&apos;Carter&apos;#我们希望从上面的 &quot;Persons&quot; 表中选取居住在以 &quot;N&quot; 开始的城市里的人SELECT * FROM Persons WHERE City LIKE &apos;N%&apos;; #提示：&quot;%&quot; 可用于定义通配符（模式中缺少的字母）。#接下来，我们希望从 &quot;Persons&quot; 表中选取居住在以 &quot;g&quot; 结尾的城市里的人：SELECT * FROM Persons WHERE City LIKE &apos;%g&apos;; 这里以后再补充补充:最简单也是用的最多,实现多样化的地方,性能各有差异 表插入数据 命令：insert into &lt;表名&gt; [( &lt;字段名1&gt;[,..&lt;字段名n &gt; ])] values ( 值1 )[, ( 值n )] insert into MyClass values(1,&apos;Tom&apos;,96.45),(2,&apos;Joan&apos;,82.99), (2,&apos;Wang&apos;, 96.59); 注意：insert into每次只能向表中插入一条记录。 修改表中数据 语法：update 表名 set 字段=新值,… where 条件 mysql&gt; UPDATE persondata SET age=age+1;mysql&gt; UPDATE persondata SET age=age*2, age=age+1; UPDATE [LOW_PRIORITY] [IGNORE] tbl_name SET col_name1=expr1 [, col_name2=expr2 ...] [WHERE where_definition] [ORDER BY ...] [LIMIT row_count] # 单表 UPDATE [LOW_PRIORITY] [IGNORE] table_references SET col_name1=expr1 [, col_name2=expr2 ...] [WHERE where_definition] ＃ 多表 增加字段 命令：**alter table** 表名 **add**字段 类型 其他; mysql&gt; alter table MyClass add passtest int(4) default '0'mysql&gt; alter table employee add index emp_name (name);mysql&gt; alter table employee add primary key(id); 加索引mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]);例子：mysql&gt; alter table employee add index emp_name (name); 加主关键字的索引mysql&gt; alter table 表名 add primary key (字段名);例子：mysql&gt; alter table employee add primary key(id); 加唯一限制条件的索引mysql&gt; alter table 表名 add unique 索引名 (字段名);例子：mysql&gt; alter table employee add unique emp_name2(cardnumber); 删除某个索引mysql&gt; alter table 表名 drop index 索引名;例子： mysql&gt;alter table employee drop index emp_name; 增加字段：mysql&gt; ALTER TABLE table_name ADD field_name field_type; 修改原字段名称及类型：mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 删除字段：MySQL ALTER TABLE table_name DROP field_name; 修改表名 命令：rename table 原表名 to 新表名; mysql&gt; rename table MyClass to YouClass; 当你执行 RENAME 时，你不能有任何锁定的表或活动的事务。你同样也必须有对原初表的 ALTER 和 DROP 权限，以及对新表的 CREATE 和 INSERT 权限。 如果在多表更名中，MySQL 遭遇到任何错误，它将对所有被更名的表进行倒退更名，将每件事物退回到最初状态。 RENAME TABLE 在 MySQL 3.23.23 中被加入。 建库和建表的实例1 drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER( id int(3) auto_increment not null primary key, name char(10) not null, address varchar(50) default ‘深圳’, year date); //建表结束//以下为插入字段insert into teacher values(”,’allen’,&apos;大连一中’,&apos;1976-10-10′);insert into teacher values(”,’jack’,&apos;大连二中’,&apos;1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。1、你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\下，并在DOS状态进入目录,然后键入以下命令：​ mysql -uroot -p密码 &lt; c:\\school.sql如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 2、或者进入命令行后使用 mysql&gt; source c:\\school.sql; 也可以将school.sql文件导入数据库中。 建库和建表的实例2 drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER( id int(3) auto_increment not null primary key, name char(10) not null, address varchar(50) default &apos;&apos;深圳&apos;&apos;, year date); //建表结束//以下为插入字段insert into teacher values(&apos;&apos;&apos;&apos;,&apos;&apos;glchengang&apos;&apos;,&apos;&apos;深圳一中&apos;&apos;,&apos;&apos;1976-10-10&apos;&apos;);insert into teacher values(&apos;&apos;&apos;&apos;,&apos;&apos;jack&apos;&apos;,&apos;&apos;深圳一中&apos;&apos;,&apos;&apos;1975-12-23&apos;&apos;); 注：在建表中1、将ID设为长度为3的数字字段:int(3)；并让它每个记录自动加一:auto_increment；并不能为空:not null；而且让他成为主字段primary key。 2、将NAME设为长度为10的字符字段 3、将ADDRESS设为长度50的字符字段，而且缺省值为深圳。 4、将YEAR设为日期字段。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年3月17日分享]]></title>
    <url>%2F2019%2F03%2F17%2F2019%E5%B9%B43%E6%9C%8817%E6%97%A5%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[这几天在做什么? ​ 我最近买了一个域名:jxiaof.com. ​ 买这个域名的初衷主要是为了把我自己的博客搭建起来.也正是这个原由,我选了这个看上去很难记忆的域名,其实江小凡的首字母缩写,当然xiao这几个字母很容记住并很容易打出来的.我一开始想选择jiangxiaofan.com作为我的个人博客域名,但是……..名字这么好听,当然被别人先一步就注册了,我看了一下2015年这个域名就被别人注册了.当然时间仓促,想象力不够丰富,不了解的东西很多,所以没有选出更好的更牛X的域名来. ​ 我这个域名是在https://www.namesilo.com注册的,一个美国公司.一年的费用是5.99$ (目前新域名只能购买一年使用权). 最近想做什么? ​ 最近想找个女朋友! ​ 想搭建一个图片存储服务器.目前还没有成功,所以我找了很多资料,有很多方法都不错.现在用的最轻松的是QQ空间相册,哈哈哈哈.毕竟中国大多数人的相册服务器.也有很多收费免收费的工具.反正做着玩. 关于我的生活 ​ 我这两天基本没有出门,除开我下楼吃饭买点水果和饮用水,一直都独自在房间里. ​ 我这样说并不是我平时都是这样的生活,仅仅是这两天没有出门.大多数的时候周末我都会出去.我这两天里我只是恰好想克服一下自己学习东西的畏惧感.我平时工作留给我很多富余的时间,我一般会出去走一走,看个电视或电影,聊天,玩游戏.唯独我不想把时间留给电脑,看文档,敲代码.真的人生很短,怎么能天天看代码呢!一不小心又几个月的时间过去,自己就更不能安静下来学习新东西.很烦,很烦. ​]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化第二篇]]></title>
    <url>%2F2019%2F03%2F15%2FMySQL%E4%BC%98%E5%8C%96%E7%AC%AC%E4%BA%8C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1、选取最适用的字段属性 MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。 例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。 另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。 ####2、使用连接（JOIN）来代替子查询(Sub-Queries)MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示： DELETE FROM customerinfoWHERE CustomerID NOT IN (SELECT CustomerID FROM salesinfo) 使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）..替代。例如，假设我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成： SELECT * FROM customerinfoWHERE CustomerID NOT IN (SELECTC ustomerID FROM salesinfo) 如果使用连接（JOIN）..来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下： SELECT * FROM customerinfoLEFT JOIN salesinfo ON customerinfo.CustomerID=salesinfo.CustomerIDWHERE salesinfo.CustomerID ISNULL 连接（JOIN）..之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。 3、使用联合(UNION)来代替手动创建的临时表 MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。 SELECT Name,Phone FROM client UNIONSELECT Name,BirthDate FROM author UNIONSELECT Name,Supplier FROM product 4、事务 尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。 BEGIN; INSERT INTO salesinfo SET CustomerID=14; UPDATE inventory SET Quantity=11 WHERE item='book'; COMMIT; 事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。 5、锁定表 尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。 其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。 LOCK TABLE inventory WRITE SELECT Quantity FROM inventory WHERE Item='book';...UPDATE inventory SET Quantity=11 WHERE Item='book'; UNLOCKTABLES 这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。 6、使用外键 锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。 例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的CustomerID映射到salesinfo表中CustomerID，任何一条没有合法CustomerID的记录都不会被更新或插入到salesinfo中。 CREATE TABLE customerinfo(CustomerIDINT NOT NULL,PRIMARYKEY(CustomerID))TYPE=INNODB;CREATE TABLE salesinfo( SalesIDNT NOT NULL,CustomerIDINT NOT NULL, PRIMARYKEY(CustomerID,SalesID),FOREIGNKEY(CustomerID) REFERENCES customerinfo(CustomerID) ON DELETE CASCADE)TYPE=INNODB; 注意例子中的参数“ON DELETE CASCADE”。该参数保证当customerinfo表中的一条客户记录被删除的时候，salesinfo表中所有与该客户相关的记录也会被自动删除。如果要在MySQL中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表InnoDB类型。该类型不是MySQL表的默认类型。定义的方法是在CREATETABLE语句中加上TYPE=INNODB。如例中所示。 7、使用索引 索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。 那该对哪些字段建立索引呢？ 一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况 例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。 8、优化的查询语句 绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用。 下面是应该注意的几个方面。 首先，最好是在相同类型的字段间进行比较的操作。 在MySQL3.23版之前，这甚至是一个必须的条件。例如不能将一个建有索引的INT字段和BIGINT字段进行比较；但是作为特殊的情况，在CHAR类型的字段和VARCHAR类型字段的字段大小相同的时候，可以将它们进行比较。 其次，在建有索引的字段上尽量不要使用函数进行操作。 例如，在一个DATE类型的字段上使用YEAE()函数时，将会使索引不能发挥应有的作用。所以，下面的两个查询虽然返回的结果一样，但后者要比前者快得多。 第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的。 例如下面的查询将会比较表中的每一条记录。 SELECT * FROM booksWHERE name like"MySQL%" 但是如果换用下面的查询，返回的结果一样，但速度就要快上很多： SELECT * FROM booksWHERE name＞="MySQL" andname ＜"MySQM" 最后，应该注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库优化]]></title>
    <url>%2F2019%2F03%2F15%2Fmysql%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[#MySQL数据库优化总结 ​ 对于一个以数据为中心的应用，数据库的好坏直接影响到程序的性能，因此数据库性能至关重要。一般来说，要保证数据库的效率，要做好以下四个方面的工作：数据库设计、sql语句优化、数据库参数配置、恰当的硬件资源和操作系统，这个顺序也表现了这四个工作对性能影响的大小。下面我们逐个阐明： ​ 一、数据库设计 适度的反范式,注意是适度的 我们都知道三范式，基于三范式建立的模型是最有效保存数 据的方式，也是最容易扩展的模式。我们在开发应用程序时，设计的数据库要最大程度的遵守三范式，特别是对于OLTP型的系统，三范式是必须遵守的规则。当 然，三范式最大的问题在于查询时通常需要join很多表，导致查询效率很低。所以有时候基于性能考虑，我们需要有意的违反三范式，适度的做冗余，以达到提 高查询效率的目的。注意这里的反范式是适度的，必须为这种做法提供充分的理由。下面就是一个糟糕的实例： 在这里，为了提高学生活动记录的检索效率，把单位名称冗余到学生活动记录表里。单位信息有500条记录，而学生活动记录在一年内大概有200万数据量。 如果学生活动记录表不冗余这个单位名称字段，只包含三个int字段和一个timestamp字段，只占用了16字节，是一个很小的表。而冗余了一个 varchar(32)的字段后则是原来的3倍，检索起来相应也多了这么多的I/O。而且记录数相差悬殊，500 VS 2000000 ，导致更新一个单位名称还要更新4000条冗余记录。由此可见，这个冗余根本就是适得其反。 下面这个冗余就很好 可以看到，[学生考试总分]是冗余的，这个分数完全可以通过[得分情况]汇总得到。在【学生考试总分】里，一次考试一个学生只有一条记录，而在【得分情 况】里，一个学生针对试卷里一个小题的一个小问一条记录，粗略的算一下比例大概是1：100。而且判卷子得分是不会轻易变的，更新的频率不高，所以说这个 冗余是比较好的。 ​ 适当建立索引 说起提高数据库性能，索引是最物美价廉的东西了。不用加内存，不用改程序，不用调sql，只要执行个正确的’create index’，查询速度就可能提高百倍千倍，这可真有诱惑力。可是天下没有免费的午餐，查询速度的提高是以插入、更新、删除的速度为代价的，这些写操作，增加了大量的I/O。由于索引的存储结构不同于表的存储，一个表的索引所占空间比数据所占空间还大的情况经常发生。这意味着我们在写数据库的时候做了很多额外的工作，而这个工作只是为了提高读的效率。因此，我们建立一个索引，必须保证这个索引不会“亏本”。一般需要遵守这样的规则： 索引的字段必须是经常作为查询条件的字段; 如果索引多个字段，第一个字段要是经常作为查询条件的。如果只有第二个字段作为查询条件，这个索引不会起到作用; 索引的字段必须有足够的区分度; Mysql 对于长字段支持前缀索引; 对表进行水平划分 如果一个表的记录数太多了，比如上千万条，而且需要经常检索，那么我们就有必要化整为零了。如果我拆成100个表，那么每个表只有10万条记录。当然这 需要数据在逻辑上可以划分。一个好的划分依据，有利于程序的简单实现，也可以充分利用水平分表的优势。比如系统界面上只提供按月查询的功能，那么把表按月 拆分成12个，每个查询只查询一个表就够了。如果非要按照地域来分，即使把表拆的再小，查询还是要联合所有表来查，还不如不拆了。所以一个好的拆分依据是 最重要的。 这里有个比较好的实例 每个学生做过的题都记录在这个表里，包括对题和错题。每个题会对应一个或多个知识点，我们需要根据错题来分析学生在哪个知识点上掌握的不足。这个表很容 易达到千万级，迫切需要拆分，那么根据什么来拆呢?从需求上看，无论是老师还是学生，最终会把焦点落在一个学生的身上。学生会关心自己，老师会关心自己班 的学生。而且每个学科的知识点是不同的。所以我们很容易想到，联合学科和知识点两个字段来拆分这个表。这样拆下来，每个表大概2万条数据，检索效率非常 高。 ​ 对表进行垂直划分 有些表记录数并不多，可能也就2、3万条，但是字段却很长，表占用空间很大，检索表时需要执行大量I/O，严重降低了性能。这个时候需要把大的字段拆分到另一个表，并且该表与原表是一对一的关系。 【试题内容】、【答案信息】两个表，最初是作为几个字段添加到【试题信息】里的，可以看到试题内容和答案这两个字段很长，在表里有3万记录时，表已经占 了1G的空间，在列试题列表时非常慢。经过分析，发现系统很多时候是根据【册】、【单元】、类型、类别、难易程度等查询条件，分页显示试题详细内容。而每 次检索都是这几个表做join，每次要扫描一遍1G的表，很郁闷啊。我们完全可以把内容和答案拆分成另一个表，只有显示详细内容的时候才读这个大表，由此 就产生了【试题内容】、【答案信息】两个表。 ​ 选择适当的字段类型，特别是主键 选择字段的一般原则是保小不保大，能用占用字节小的字段就不用大字段。比如主键， 我们强烈建议用自增类型，不用guid，为什么?省空间啊?空间是什么?空间就是效率!按4个字节和按32个字节定位一条记录，谁快谁慢太明显了。涉及到 几个表做join时，效果就更明显了。值得一提的是，datetime和timestamp，datetime占用8个字节，而timestamp占用4 个字节，只用了一半，而timestamp表示的范围是1970—2037，对于大多数应用，尤其是记录什么考试时间，登录时间这类信息，绰绰有余啊。 文件、图片等大文件用文件系统存储，不用数据库 不用多说，铁律!!!数据库只存储路径。 外键表示清楚，方便建立索引 我们都知道，在powerdesigner里为两个实体建立关系，生成物理模型时会自动给外键建立索引。所以我们不要怕建立关系把线拉乱，建立个ShortCut就好了。 掌握表的写入时机 在库模式相同的情况下，如何使用数据库也对性能有着重要作用。同样是写入一个表，先写和后写对后续的操作会产生很大影响。例如在上面提到的适度冗余里的例子， 我们最初的目的是记录考生的总分，以达到提高检索效率的目的，也就是在录入成绩时写入这个表。在需求里有这样的要求：列出本次考试的所有学生成绩，没有 录入成绩的也显示该学生名称，只是总分显示为空。这个查询就需要用【学生信息】left outer join 【学生考试总分信息】，大家都知道outer join 的效率比join是要低的，为了避免这个问题，我们就在布置考试的时候写入这个表，把所有学生都插入进去，分数都是null，这样一来我们就可以用 join达到这个效果了。而且还有这样的好处：在某次考试中，安排了一个班所有学生考试，所有学生都录入了成绩。现在班里转来一个新生，那么在此时如果查 询学生成绩，就会列出这个新生，结果是未录入成绩，这显然是不对的。如果在安排的时候就写入，就可以记录下该次考试中实际的考生了，这个表的作用，也就不 知是冗余了。 宁可集中批量操作，避免频繁读写 系统里包含了积分部分，学生和老师通过系统做了操作都可以获得积分，而且积分规 则很复杂，限制每类操作获得积分不同，每人每天每类积分都有上限。比如登录，一次登录就可以获得1分，但是不管你登录多少次，一天只能累积一个登录积分。 这个还是简单的，有的积分很变态，比如老师积分中有一类是看老师判作业的情况，规则是：老师判了作业，发现学生有错的，学生改过了，老师再判，如果这时候 学生都对了，就给老师加分，如果学生还是错的，那就接着改，知道学生都改对了，老师都判完了，才能给老师加分。如果用程序来处理，很可能每个功能都会额外 的写一堆代码来处理这个鸡肋似的积分。不仅编程的同事干活找不到重点，还平白给数据库带来了很大的压力。经过和需求人员的讨论，确定积分没有必要实时累 积，于是我们采取后台脚本批量处理的方式。夜深人静的时候，让机器自己玩去吧。 这个变态的积分规则用批处理读出来是这样的： select person_id, @semester_id, 301003, 0, @one_marks, assign_date, @one_marks from hom_assignmentinfo ha, hom_assign_class hac where ha.assignment_id = hac.assignment_id and ha.assign_date between @time_begin and @time_end and ha.assignment_id not in ( select haa.assignment_id from hom_assignment_appraise haa, hom_check_assignment hca where haa.appraise_id = hca.appraise_id and haa.if_submit=1 and ( (hca.recheck_state = 3004001 and hca.check_result in (3003002, 3003003) ) or (hca.recheck_state = 3004002 and hca.recheck_result in (3003002, 3003003)) ) ) and ha.assignment_id not in ( select assignment_id from hom_assignment_appraise where if_submit=0 and result_type = 0 ) and ha.assignment_id in ( select haa.assignment_id from hom_assignment_appraise haa, hom_check_assignment hca where haa.appraise_id = hca.appraise_id and haa.if_submit=1 and hca.check_result in (3003002, 3003003) ); 这还只是个中间过程，这要是用程序实时处理，即使编程人员不罢工，数据库也会歇了。 选择合适的引擎 Mysql提供了很多种引擎，我们用的最多的是myisam，innodb，memory这三类。官方手册上说道myisqm比innodb的读速度要 快，大概是3倍。不过书不能尽信啊，《OreIlly.High.Performance.Mysql》这本书里提到了myisam和innodb的比 较，在测试中myisam的表现还不及innodb。至于memory，哈哈，还是比较好用的。在批处理种作临时表是个不错的选择(如果内存够大)。在我的一个批处理中，速度比近乎1：10。 ​ 二、SQL语句优化 Sql语句优化工具 ·慢日志 如果发现系统慢了，又说不清楚是哪里慢，那么就该用这个工具了。只需要为mysql配置参数，mysql会自己记录下来慢的sql语句。配置很简单，参数文件里配置： slow_query_log=d:/slow.txt long_query_time = 2 就可以在d:/slow.txt里找到执行时间超过2秒的语句了，根据这个文件定位问题吧。 ·mysqldumpslow.pl 慢日志文件可能会很大，让人去看是很难受的事。这时候我们可以通过mysql自带的工具来分析。这个工具可以格式化慢日志文件，对于只是参数不同的语句 会归类类并，比如有两个语句select from a where id=1 和select from a where id=2，经过这个工具整理后就只剩下select * from a where id=N，这样读起来就舒服多了。而且这个工具可以实现简单的排序，让我们有的放矢。 Explain 现在我们已经知道是哪个语句慢了，那么它为什么慢呢?看看mysql是怎么执行的吧，用explain可以看到mysql执行计划，下面的用法来源于手册 EXPLAIN语法(获取SELECT相关信息) EXPLAIN [EXTENDED] SELECT select_options EXPLAIN语句可以用作DESCRIBE的一个同义词，或获得关于MySQL如何执行SELECT语句的信息： · EXPLAIN tbl_name是DESCRIBE tbl_name或SHOW COLUMNS FROM tbl_name的一个同义词。 · 如果在SELECT语句前放上关键词EXPLAIN，MySQL将解释它如何处理SELECT，提供有关表如何联接和联接的次序。 该节解释EXPLAIN的第2个用法。 借助于EXPLAIN，可以知道什么时候必须为表加入索引以得到一个使用索引来寻找记录的更快的SELECT。 如果由于使用不正确的索引出现了问题，应运行ANALYZE TABLE更新表的统计(例如关键字集的势)，这样会影响优化器进行的选择。 还可以知道优化器是否以一个最佳次序联接表。为了强制优化器让一个SELECT语句按照表命名顺序的联接次序，语句应以STRAIGHT_JOIN而不只是SELECT开头。 EXPLAIN为用于SELECT语句中的每个表返回一行信息。表以它们在处理查询过程中将被MySQL读入的顺序被列出。MySQL用一遍扫描多次联 接(single-sweep multi-join)的方式解决所有联接。这意味着MySQL从第一个表中读一行，然后找到在第二个表中的一个匹配行，然后在第3个表中等等。当所有的 表处理完后，它输出选中的列并且返回表清单直到找到一个有更多的匹配行的表。从该表读入下一行并继续处理下一个表。 当使用EXTENDED关键字时，EXPLAIN产生附加信息，可以用SHOW WARNINGS浏览。该信息显示优化器限定SELECT语句中的表和列名，重写并且执行优化规则后SELECT语句是什么样子，并且还可能包括优化过程的其它注解。 如果什么都做不了，试试全索引扫描 如果一个语句实在不能优化了，那么还有一个方法可以试试：索引覆盖。 如果一个语句可以从索引上获取全部数据，就不需要通过索引再去读表，省了很多I/O。比如这样一个表 如果我要统计每个学生每道题的得分情况，我们除了要给每个表的主键外键建立索引，还要对【得分情况】的实际得分字段索引，这样，整个查询就可以从索引得到数据了。 三、数据库参数配置 ​ 最重要的参数就是内存，我们主要用的innodb引擎，所以下面两个参数调的很大 # Additional memory pool that is used by InnoDB to store metadata# information. If InnoDB requires more memory for this purpose it will# start to allocate it from the OS. As this is fast enough on most# recent operating systems, you normally do not need to change this# value. SHOW INNODB STATUS will display the current amount used.innodb_additional_mem_pool_size = 64M# InnoDB, unlike MyISAM, uses a buffer pool to cache both indexes and# row data. The bigger you set this the less disk I/O is needed to# access data in tables. On a dedicated database server you may set this# parameter up to 80% of the machine physical memory size. Do not set it# too large, though, because competition of the physical memory may# cause paging in the operating system. Note that on 32bit systems you# might be limited to 2-3.5G of user level memory per process, so do not# set it too high.innodb_buffer_pool_size = 5G 对于myisam，需要调整key_buffer_size 当然调整参数还是要看状态，用show status语句可以看到当前状态，以决定改调整哪些参数 Cretated_tmp_disk_tables 增加tmp_table_size Handler_read_key 高表示索引正确 Handler_read_rnd高表示索引不正确 Key_reads/Key_read_requests 应小于0.01 计算缓存损失率，增加Key_buffer_size Opentables/Open_tables 增加table_cache select_full_join 没有实用索引的链接的数量。如果不为0，应该检查索引。 select_range_check 如果不为0，该检查表索引。 sort_merge_passes 排序算法已经执行的合并的数量。如果该值较大，应增加sort_buffer_size table_locks_waited 不能立即获得的表的锁的次数，如果该值较高，应优化查询 Threads_created 创建用来处理连接的线程数。如果Threads_created较大，要增加 thread_cache_size值。 缓存访问率的计算方法Threads_created/Connections。 ​ 四、合理的硬件资源和操作系统 如果你的机器内存超过4G，那么毋庸置疑应当采用64位操作系统和64位mysql 读写分离 如果数据库压力很大，一台机器支撑不了，那么可以用mysql复制实现多台机器同步，将数据库的压力分散。 Master Slave1 Slave2 Slave3 主库master用来写入，slave1—slave3都用来做select，每个数据库分担的压力小了很多。 要实现这种方式，需要程序特别设计，写都操作master，读都操作slave，给程序开发带来了额外负担。当然目前已经有中间件来实现这个代理，对程 序来读写哪些数据库是透明的。官方有个mysql-proxy，但是还是alpha版本的。新浪有个amobe for mysql，也可达到这个目的，结构如下 使用方法可以看amobe的手册。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Categories]]></title>
    <url>%2F2019%2F03%2F14%2Fcategories%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first blogs]]></title>
    <url>%2F2019%2F03%2F14%2FMy-first-blogs%2F</url>
    <content type="text"><![CDATA[HELLO WORLD 今天我打算开通我自己的个人博客这个博客主要为静态页面展示.今天先这样,接下来我会把我的一些工作和生活分享在这个博客中. DEMO 下面是我手写的一个快速排序算法: quick_sort=lambda array:array if len(array)&lt;=1 else quick_sort([i for i in array[1:] if i&lt;=array[0]]) + [array[0]] + quick_sort([i for i in array[1:] if i &gt; array[0]]) THE END]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>中国/深圳</tag>
      </tags>
  </entry>
</search>
